---
phase: 02-document-upload-system
plan: 01
type: execute
---

<objective>
Implement core upload services: document picker abstraction, image compression, and Supabase Storage upload.

Purpose: Create the service layer that handles file selection, optimization, and storage upload - the foundation all document features depend on.
Output: Working services in `src/features/wallet/services/` that can pick files, compress images, and upload to Supabase Storage.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-document-upload-system/02-RESEARCH.md

**Phase 1 Summaries (dependency):**
@.planning/phases/01-foundation/SUMMARY-01-01.md
@.planning/phases/01-foundation/SUMMARY-01-02.md
@.planning/phases/01-foundation/SUMMARY-01-03.md

**Existing code:**
@src/features/wallet/types.ts
@src/features/wallet/store.ts
@src/features/wallet/services/index.ts
@src/api/supabase.ts

**Tech stack available:**

- @supabase/supabase-js ^2.86.2 (already installed)
- react-native-url-polyfill ^2.0.0 (already installed)
- expo-file-system ~18.0.12 (bundled with Expo SDK 52)

**Established patterns:**

- ArrayBuffer upload for React Native (from RESEARCH.md)
- Security definer functions for RLS membership
- Path-based storage: personal/{user_id}/ and trips/{trip_id}/

**Constraining decisions:**

- Phase 1: Storage bucket named `wallet-documents`
- Phase 1: 10MB file size limit
- Phase 1: Allowed MIME types: PDF, JPEG, PNG, HEIC, HEIF, WebP
  </context>

<tasks>

<task type="auto">
  <name>Task 1: Install Expo file picker dependencies</name>
  <files>package.json</files>
  <action>
Install the required Expo packages for file picking, image manipulation, and base64 conversion:

```bash
npx expo install expo-image-picker expo-document-picker expo-image-manipulator expo-file-system
npm install base64-arraybuffer
```

The `base64-arraybuffer` package is needed to convert Base64 strings to ArrayBuffer for Supabase upload (used in Task 3's `uploadDocument()` function with `import { decode } from 'base64-arraybuffer'`).

After installation, verify packages are in package.json dependencies.

**Do NOT:**

- Use react-native-image-crop-picker (requires bare workflow)
- Use react-native-compressor (separate native module)
- Manually edit package.json for Expo packages (use expo install)
  </action>
  <verify>
  Run `npm ls expo-image-picker expo-document-picker expo-image-manipulator expo-file-system base64-arraybuffer` - all packages should be listed without errors
  </verify>
  <done>
  All packages installed and listed in package.json dependencies (including base64-arraybuffer for ArrayBuffer conversion)
  </done>
  </task>

<task type="auto">
  <name>Task 2: Create document picker and image compression services</name>
  <files>src/features/wallet/services/documentPicker.ts, src/features/wallet/services/imageCompressor.ts</files>
  <action>
Create document picker service at `src/features/wallet/services/documentPicker.ts`:

1. Define `PickedFile` interface:

   ```typescript
   export interface PickedFile {
     uri: string;
     mimeType: string;
     name: string;
     size?: number;
   }
   ```

2. Implement `pickImage()`:
   - Use `ImagePicker.launchImageLibraryAsync()` with mediaTypes: ['images']
   - Set allowsEditing: true, quality: 0.8, exif: false
   - Return null if canceled, else return PickedFile

3. Implement `pickDocument(types?: string[])`:

   **Explicit MIME allowlist (no wildcards):**

   ```typescript
   export const ALLOWED_MIME_TYPES = [
     'application/pdf',
     'image/jpeg',
     'image/png',
     'image/heic',
     'image/heif',
     'image/webp',
   ] as const;
   ```

   - Default types parameter to `ALLOWED_MIME_TYPES`
   - Use `DocumentPicker.getDocumentAsync({ type: types, copyToCacheDirectory: true })`
   - **CRITICAL:** `copyToCacheDirectory: true` converts Android content:// URIs to file:// URIs
   - Return `null` if canceled (`result.canceled === true`)
   - **Validate MIME type immediately** after successful result: `validateMimeType(result.mimeType)`
   - Return `PickedFile` with validated contentType if successful

4. Add `validateMimeType(contentType: string)` helper:
   - Check if contentType is in ALLOWED_MIME_TYPES
   - Throw descriptive error if not: `"Unsupported file type: ${contentType}. Allowed: PDF, JPEG, PNG, HEIC, HEIF, WebP"`
   - Call this in `uploadDocument()` before upload to block unsupported formats consistently

5. Implement `takePhoto()`:
   - Use `ImagePicker.launchCameraAsync()` with same options as pickImage

Create image compressor service at `src/features/wallet/services/imageCompressor.ts`:

1. Define constants:

   ```typescript
   const MAX_DIMENSION = 1920;
   const COMPRESSION_QUALITY = 0.8;
   ```

2. Implement `compressImage(uri: string): Promise<string>`:
   - Use `ImageManipulator.manipulateAsync()`
   - Resize to MAX_DIMENSION width (maintains aspect ratio)
   - Compress with quality 0.8, JPEG format
   - Return compressed image URI

3. Implement `shouldCompress(mimeType: string): boolean`:
   - Return true for image/\* types
   - Return false for PDFs and other documents

**Do NOT:**

- Use FormData or Blob directly (doesn't work in React Native)
- Skip copyToCacheDirectory (files won't be readable)
- Forget to handle null/undefined asset properties
  </action>
  <verify>
  Files exist at paths, TypeScript compilation passes: `npx tsc --noEmit src/features/wallet/services/documentPicker.ts src/features/wallet/services/imageCompressor.ts 2>&1 | head -20`
  </verify>
  <done>
- documentPicker.ts exports: PickedFile interface, pickImage(), pickDocument(), takePhoto()
- imageCompressor.ts exports: compressImage(), shouldCompress()
- No TypeScript errors
  </done>
  </task>

<task type="auto">
  <name>Task 3: Create Supabase Storage upload service</name>
  <files>src/features/wallet/services/storageUpload.ts, src/features/wallet/services/index.ts</files>
  <action>
Create storage upload service at `src/features/wallet/services/storageUpload.ts`:

1. Import supabase client from `@/src/api/supabase`

2. Define constants:

   ```typescript
   export const STORAGE_BUCKET = 'wallet-documents';
   export const MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB
   ```

3. Implement `generateStoragePath()`:

   ```typescript
   export function generateStoragePath(
     walletType: WalletType,
     userId: string,
     tripId: string | undefined,
     fileName: string
   ): string;
   ```

   **Path format by WalletType:**
   - Personal: `personal/${userId}/${timestamp}_${sanitizedFileName}`
   - Group: `trips/${tripId}/${timestamp}_${sanitizedFileName}`

   **Input validation (MUST throw before path construction):**
   - If `walletType === 'Group' && !tripId`, throw: `"tripId is required for Group wallet uploads"`

   **Filename sanitization (MUST be deterministic):**
   1. Normalize to NFC and lowercase: `fileName.normalize('NFC').toLowerCase()`
   2. Replace all whitespace sequences with underscore: `.replace(/\s+/g, '_')`
   3. Remove characters not in whitelist `[a-z0-9._-]`: `.replace(/[^a-z0-9._-]/g, '')`
   4. Collapse repeated dots/underscores/hyphens to single char: `.replace(/([._-])\1+/g, '$1')`
   5. Trim leading/trailing dots/underscores/hyphens: `.replace(/^[._-]+|[._-]+$/g, '')`
   6. Fallback to `'document'` if result is empty after sanitization

   **Example implementation:**

   ```typescript
   function sanitizeFileName(fileName: string): string {
     let sanitized = fileName
       .normalize('NFC')
       .toLowerCase()
       .replace(/\s+/g, '_')
       .replace(/[^a-z0-9._-]/g, '')
       .replace(/([._-])\1+/g, '$1')
       .replace(/^[._-]+|[._-]+$/g, '');
     return sanitized || 'document';
   }
   ```

4. Implement `uploadDocument()`:

   ```typescript
   export async function uploadDocument(
     fileUri: string,
     storagePath: string,
     contentType: string,
     fileSize?: number // Optional: from PickedFile.size
   ): Promise<{ path: string; fullPath: string }>;
   ```

   **Pre-upload size validation:**
   - If `fileSize` is provided (from DocumentPicker), compare against MAX_FILE_SIZE immediately
   - If `fileSize` is undefined, use `FileSystem.getInfoAsync(fileUri)` to get actual file size
   - Throw descriptive error if file exceeds 10MB limit: `"File size (${sizeMB}MB) exceeds maximum allowed (10MB)"`
   - Validate BEFORE reading file to avoid unnecessary memory usage

   **Android content:// URI handling (CRITICAL for cross-platform):**
   - DocumentPicker with `copyToCacheDirectory: true` returns file:// URI (not content://)
   - Use `FileSystem.readAsStringAsync(fileUri, { encoding: FileSystem.EncodingType.Base64 })` to read file
   - Convert base64 to ArrayBuffer using the `base64-arraybuffer` package:
     ```typescript
     import { decode } from 'base64-arraybuffer';
     const arrayBuffer = decode(base64String);
     ```
   - **Note:** The old `fetch(fileUri).then(res => res.arrayBuffer())` approach may fail on Android content:// URIs

   **Upload to Supabase:**
   - Upload with `supabase.storage.from(STORAGE_BUCKET).upload(storagePath, arrayBuffer, options)`
   - Set contentType, cacheControl: '3600', upsert: false
   - Throw descriptive error on failure
   - Return { path: data.path, fullPath: data.fullPath }

5. Implement `getSignedUrl()`:

   ```typescript
   export async function getSignedUrl(
     storagePath: string,
     expiresIn: number = 3600
   ): Promise<string>;
   ```

   - Use `supabase.storage.from(STORAGE_BUCKET).createSignedUrl()`
   - Throw on error

6. Implement `deleteDocument()`:

   ```typescript
   export async function deleteDocument(storagePath: string): Promise<void>;
   ```

   - Use `supabase.storage.from(STORAGE_BUCKET).remove([storagePath])`

Update `src/features/wallet/services/index.ts`:

- Re-export all functions from documentPicker, imageCompressor, storageUpload

**Do NOT:**

- Use FormData, Blob, or File constructors (React Native incompatible)
- Use `fetch(uri).then(res => res.arrayBuffer())` on Android content:// URIs (may fail)
- Skip pre-upload size validation (avoid loading large files into memory)
- Allow files over 10MB (bucket rejects them)
- Include user-controlled data in storage paths without sanitization
  </action>
  <verify>
  Run type check: `npx tsc --noEmit src/features/wallet/services/*.ts 2>&1 | head -30`
  </verify>
  <done>
- storageUpload.ts exports: STORAGE_BUCKET, MAX_FILE_SIZE, generateStoragePath(), uploadDocument(), getSignedUrl(), deleteDocument()
- index.ts re-exports all services
- No TypeScript errors
- Base64 to ArrayBuffer pattern used via FileSystem.readAsStringAsync (Android-compatible)
- Pre-upload size validation implemented (check before reading file)
  </done>
  </task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm ls expo-image-picker expo-document-picker expo-image-manipulator expo-file-system base64-arraybuffer` shows all installed
- [ ] `npx tsc --noEmit` passes for all service files
- [ ] Services follow RESEARCH.md patterns (ArrayBuffer upload, compression)
- [ ] Path generation matches Phase 1 RLS patterns (personal/{userId}/, trips/{tripId}/)
</verification>

<success_criteria>

- All three Expo packages installed
- documentPicker.ts with pickImage, pickDocument, takePhoto
- imageCompressor.ts with compressImage, shouldCompress
- storageUpload.ts with uploadDocument, getSignedUrl, deleteDocument
- All exports re-exported from services/index.ts
- No TypeScript errors
- Base64 to ArrayBuffer upload pattern used (Android content:// URI compatible)
- Pre-upload file size validation before reading into memory
  </success_criteria>

<output>
After completion, create `.planning/phases/02-document-upload-system/02-01-SUMMARY.md` following summary.md template.

Include:

- Packages installed and versions
- Services created with their exports
- Any deviations from plan
- Ready for Plan 02-02 (store integration)
  </output>
