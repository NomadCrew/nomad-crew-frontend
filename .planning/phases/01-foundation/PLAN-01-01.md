# Plan 01-01: Database Schema and Migrations

**Phase:** 1 - Foundation
**Plan:** 01-01
**Status:** Ready for execution

## Goal

Create the PostgreSQL database schema for the wallet_documents table with proper RLS policies, constraints, and a security definer function for group access. This establishes the data foundation for both personal and group wallets.

## Context

From research (01-RESEARCH.md):
- Use `wallet_type` column to differentiate personal vs group documents
- Group documents require `trip_id` (enforced via CHECK constraint)
- RLS policies separate personal (owner-only) from group (trip members)
- Security definer function avoids RLS recursion for membership checks

Existing patterns (INTEGRATIONS.md):
- Supabase PostgreSQL accessed via API, not direct DB access
- Schema changes deployed via Supabase dashboard or migrations

## Tasks

### Task 1: Create wallet_documents table schema

**What:** Define the wallet_documents table with all columns, constraints, and indexes

**File:** `.planning/phases/01-foundation/migrations/001_wallet_documents.sql`

**Implementation:**
```sql
-- Migration: 001_wallet_documents.sql
-- Purpose: Create wallet_documents table for personal and group document storage

-- Create document_type enum for type safety
CREATE TYPE document_type AS ENUM (
  'passport',
  'visa',
  'insurance',
  'vaccination',
  'loyalty_card',
  'flight_booking',
  'hotel_booking',
  'reservation',
  'receipt',
  'other'
);

-- Create wallet_type enum
CREATE TYPE wallet_type AS ENUM ('personal', 'group');

-- Create wallet_documents table
CREATE TABLE wallet_documents (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  wallet_type wallet_type NOT NULL,
  trip_id UUID REFERENCES trips(id) ON DELETE CASCADE,
  document_type document_type NOT NULL,
  name TEXT NOT NULL,
  description TEXT,
  storage_path TEXT NOT NULL,
  mime_type TEXT NOT NULL,
  file_size INTEGER NOT NULL CHECK (file_size > 0),
  metadata JSONB DEFAULT '{}',
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  -- Group wallet requires trip_id
  CONSTRAINT group_requires_trip CHECK (
    wallet_type = 'personal' OR trip_id IS NOT NULL
  ),

  -- Personal wallet must not have trip_id
  CONSTRAINT personal_no_trip CHECK (
    wallet_type = 'group' OR trip_id IS NULL
  )
);

-- Indexes for common queries
CREATE INDEX idx_wallet_docs_user_id ON wallet_documents(user_id);
CREATE INDEX idx_wallet_docs_trip_id ON wallet_documents(trip_id) WHERE trip_id IS NOT NULL;
CREATE INDEX idx_wallet_docs_wallet_type ON wallet_documents(wallet_type);
CREATE INDEX idx_wallet_docs_document_type ON wallet_documents(document_type);
CREATE INDEX idx_wallet_docs_created_at ON wallet_documents(created_at DESC);

-- Composite index for personal wallet queries
CREATE INDEX idx_wallet_docs_personal ON wallet_documents(user_id, wallet_type)
  WHERE wallet_type = 'personal';

-- Composite index for group wallet queries
CREATE INDEX idx_wallet_docs_group ON wallet_documents(trip_id, wallet_type)
  WHERE wallet_type = 'group';

-- Updated_at trigger
CREATE OR REPLACE FUNCTION update_wallet_documents_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER wallet_documents_updated_at
  BEFORE UPDATE ON wallet_documents
  FOR EACH ROW
  EXECUTE FUNCTION update_wallet_documents_updated_at();

-- Enable RLS
ALTER TABLE wallet_documents ENABLE ROW LEVEL SECURITY;
```

**Why this approach:**
- ENUMs provide type safety and prevent invalid values at DB level
- CHECK constraints enforce business rules (group requires trip, personal has no trip)
- Multiple indexes optimize common query patterns (by user, by trip, by type)
- Composite indexes speed up filtered queries
- Updated_at trigger maintains data integrity automatically

**Verification:**
- [ ] Table creates without errors
- [ ] Inserting personal doc with trip_id fails (constraint)
- [ ] Inserting group doc without trip_id fails (constraint)
- [ ] Indexes created and visible in pg_indexes

---

### Task 2: Create security definer function for trip membership

**What:** Create a function that returns trip IDs for a user, bypassing RLS to avoid recursion

**File:** `.planning/phases/01-foundation/migrations/002_get_user_trip_ids.sql`

**Implementation:**
```sql
-- Migration: 002_get_user_trip_ids.sql
-- Purpose: Security definer function for checking trip membership without RLS recursion

-- First, verify the trip_members table structure exists
-- (This should already exist from the trips feature)
-- Expected structure: trip_id UUID, user_id UUID, role TEXT

CREATE OR REPLACE FUNCTION get_user_trip_ids(uid UUID)
RETURNS SETOF UUID
LANGUAGE sql
STABLE
SECURITY DEFINER
SET search_path = public
AS $$
  SELECT DISTINCT trip_id
  FROM trip_members
  WHERE user_id = uid
$$;

-- Grant execute permission to authenticated users
GRANT EXECUTE ON FUNCTION get_user_trip_ids(UUID) TO authenticated;

-- Comment for documentation
COMMENT ON FUNCTION get_user_trip_ids IS
  'Returns trip IDs where the user is a member. SECURITY DEFINER to bypass RLS.';
```

**Note:** If `trip_members` table doesn't exist, need to:
1. Check if trips use a different membership pattern (embedded array?)
2. Adapt the function to query the actual membership source
3. May need to create a `trip_members` view or table

**Investigation required:**
- Run: `SELECT * FROM information_schema.tables WHERE table_name LIKE '%member%'`
- Check trips table structure for embedded members

**Why this approach:**
- SECURITY DEFINER runs with owner privileges, bypassing RLS
- SET search_path prevents search_path injection attacks
- STABLE indicates function returns same results for same inputs within a transaction
- DISTINCT prevents duplicate trip_ids if user has multiple roles

**Verification:**
- [ ] Function creates without errors
- [ ] Returns correct trip IDs for test user
- [ ] Works when called from RLS policy context

---

### Task 3: Create RLS policies for wallet_documents

**What:** Define Row Level Security policies for personal and group document access

**File:** `.planning/phases/01-foundation/migrations/003_wallet_documents_rls.sql`

**Implementation:**
```sql
-- Migration: 003_wallet_documents_rls.sql
-- Purpose: RLS policies for wallet_documents table

-- Policy 1: Personal documents - full access for owner only
CREATE POLICY "Users can manage their personal documents"
ON wallet_documents
FOR ALL
USING (
  wallet_type = 'personal' AND
  user_id = auth.uid()
)
WITH CHECK (
  wallet_type = 'personal' AND
  user_id = auth.uid()
);

-- Policy 2: Group documents - SELECT for trip members
CREATE POLICY "Trip members can view group documents"
ON wallet_documents
FOR SELECT
USING (
  wallet_type = 'group' AND
  trip_id IN (SELECT get_user_trip_ids(auth.uid()))
);

-- Policy 3: Group documents - INSERT for trip members (owner of doc is uploader)
CREATE POLICY "Trip members can upload group documents"
ON wallet_documents
FOR INSERT
WITH CHECK (
  wallet_type = 'group' AND
  trip_id IN (SELECT get_user_trip_ids(auth.uid())) AND
  user_id = auth.uid()  -- Uploader becomes document owner
);

-- Policy 4: Group documents - UPDATE/DELETE only for document owner
CREATE POLICY "Document owners can update group documents"
ON wallet_documents
FOR UPDATE
USING (
  wallet_type = 'group' AND
  user_id = auth.uid() AND
  trip_id IN (SELECT get_user_trip_ids(auth.uid()))
)
WITH CHECK (
  wallet_type = 'group' AND
  user_id = auth.uid() AND
  trip_id IN (SELECT get_user_trip_ids(auth.uid()))
);

CREATE POLICY "Document owners can delete group documents"
ON wallet_documents
FOR DELETE
USING (
  wallet_type = 'group' AND
  user_id = auth.uid() AND
  trip_id IN (SELECT get_user_trip_ids(auth.uid()))
);
```

**Policy summary:**
| Wallet Type | Operation | Who Can Do It |
|-------------|-----------|---------------|
| Personal | ALL | Owner only |
| Group | SELECT | All trip members |
| Group | INSERT | Trip members (become owner) |
| Group | UPDATE | Document owner + trip member |
| Group | DELETE | Document owner + trip member |

**Why this approach:**
- Separate policies for clarity and maintainability
- Personal docs completely isolated to owner
- Group docs viewable by all trip members for collaboration
- Only document uploader can modify/delete to prevent conflicts
- Uses security definer function to check membership

**Verification:**
- [ ] User A cannot see User B's personal documents
- [ ] Trip member can see group documents for their trips
- [ ] Non-member cannot see group documents
- [ ] Only document owner can update/delete group docs

---

## Dependencies

- **Requires:** Supabase project access, migrations capability
- **Blocks:** Plan 01-02 (Storage bucket needs documents table), Plan 01-03 (Types need schema)

## Acceptance Criteria

1. `wallet_documents` table exists with all columns and constraints
2. `get_user_trip_ids` function works without RLS recursion
3. RLS policies enforce:
   - Personal documents accessible only to owner
   - Group documents viewable by trip members
   - Only document owner can modify group documents
4. All migrations documented and versioned

## Notes

- **Backend coordination:** May need to verify `trip_members` table/view exists
- **Testing:** Use Supabase SQL editor to test policies with different user contexts
- **Rollback:** Keep DROP statements ready in case schema needs changes

---

*Plan created: 2026-01-10*
*Ready for execution*
