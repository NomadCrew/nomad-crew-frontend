# Plan 01-03: Core TypeScript Types and Zustand Store Skeleton

**Phase:** 1 - Foundation
**Plan:** 01-03
**Status:** Ready for execution

## Goal

Create the TypeScript type definitions and Zustand store skeleton for the wallet feature, following existing codebase patterns from the trips feature.

## Context

From research (01-RESEARCH.md):
- Document types: passport, visa, insurance, vaccination, loyalty_card, flight_booking, hotel_booking, reservation, receipt, other
- Wallet types: personal, group
- Metadata varies by document type (expiry dates for travel docs, confirmation numbers for bookings)

Existing patterns (ARCHITECTURE.md, trips feature):
- Feature-based organization: `src/features/{feature}/`
- Types in `types.ts`, store in `store.ts`
- Zustand with devtools middleware
- Adapters for normalizing backend data
- Stores include: state, actions, loading/error states

## Tasks

### Task 1: Create wallet feature directory structure

**What:** Set up the feature directory with standard files

**Directories and files to create:**
```
src/features/wallet/
├── types.ts              # Type definitions
├── store.ts              # Zustand store skeleton
├── adapters/
│   └── normalizeDocument.ts  # Backend → frontend transform
├── hooks/
│   └── index.ts          # Re-export hooks (placeholder)
├── components/
│   └── index.ts          # Re-export components (placeholder)
└── services/
    └── index.ts          # Re-export services (placeholder)
```

**Implementation:**

Create placeholder files with proper structure:

**`src/features/wallet/components/index.ts`:**
```typescript
// Wallet UI components
// Components will be added in Phase 3+
export {};
```

**`src/features/wallet/hooks/index.ts`:**
```typescript
// Wallet hooks
// Hooks will be added in Phase 2+
export {};
```

**`src/features/wallet/services/index.ts`:**
```typescript
// Wallet services (storage, upload)
// Services will be added in Phase 2
export {};
```

**Why this approach:**
- Matches existing feature structure (trips, chat, todos)
- Placeholder files establish structure early
- Easy to locate wallet-related code
- Supports future expansion

**Verification:**
- [ ] Directory structure matches pattern
- [ ] All placeholder files created
- [ ] No import errors in codebase

---

### Task 2: Create TypeScript type definitions

**What:** Define all types for wallet documents

**File:** `src/features/wallet/types.ts`

**Implementation:**
```typescript
// src/features/wallet/types.ts
// Type definitions for wallet documents

/**
 * Document type categories
 */
export type DocumentType =
  | 'passport'
  | 'visa'
  | 'insurance'
  | 'vaccination'
  | 'loyalty_card'
  | 'flight_booking'
  | 'hotel_booking'
  | 'reservation'
  | 'receipt'
  | 'other';

/**
 * Wallet type - personal or group (trip-associated)
 */
export type WalletType = 'personal' | 'group';

/**
 * Metadata for travel documents (passport, visa, etc.)
 */
export interface TravelDocumentMetadata {
  documentNumber?: string;
  issuingCountry?: string;
  expiryDate?: string;  // ISO date string
  issueDate?: string;   // ISO date string
}

/**
 * Metadata for booking documents (flights, hotels, etc.)
 */
export interface BookingMetadata {
  confirmationNumber?: string;
  provider?: string;      // Airline, hotel chain, etc.
  departureTime?: string; // ISO datetime for flights
  arrivalTime?: string;   // ISO datetime for flights
  checkInDate?: string;   // ISO date for hotels
  checkOutDate?: string;  // ISO date for hotels
  location?: string;      // Address or destination
}

/**
 * Metadata for receipts
 */
export interface ReceiptMetadata {
  amount?: number;
  currency?: string;
  merchant?: string;
  category?: 'accommodation' | 'food' | 'transport' | 'activity' | 'shopping' | 'other';
  date?: string;  // ISO date string
}

/**
 * Metadata for loyalty cards
 */
export interface LoyaltyCardMetadata {
  programName?: string;
  memberNumber?: string;
  tier?: string;
  expiryDate?: string;
}

/**
 * Union type for all metadata variants
 */
export type DocumentMetadata =
  | TravelDocumentMetadata
  | BookingMetadata
  | ReceiptMetadata
  | LoyaltyCardMetadata
  | Record<string, unknown>;  // For 'other' type

/**
 * Core wallet document entity
 */
export interface WalletDocument {
  id: string;
  userId: string;
  walletType: WalletType;
  tripId?: string;  // Required for group, null for personal
  documentType: DocumentType;
  name: string;
  description?: string;
  storagePath: string;
  mimeType: string;
  fileSize: number;
  metadata: DocumentMetadata;
  createdAt: string;  // ISO datetime
  updatedAt: string;  // ISO datetime
}

/**
 * Input for creating a new document
 */
export interface CreateDocumentInput {
  walletType: WalletType;
  tripId?: string;
  documentType: DocumentType;
  name: string;
  description?: string;
  metadata?: DocumentMetadata;
  // File info populated during upload
  fileUri: string;  // Local file URI
  mimeType: string;
}

/**
 * Input for updating a document
 */
export interface UpdateDocumentInput {
  name?: string;
  description?: string;
  documentType?: DocumentType;
  metadata?: DocumentMetadata;
}

/**
 * Filters for querying documents
 */
export interface DocumentFilters {
  walletType?: WalletType;
  tripId?: string;
  documentType?: DocumentType | DocumentType[];
  search?: string;
}

/**
 * Document with signed URL for viewing
 */
export interface WalletDocumentWithUrl extends WalletDocument {
  signedUrl: string;
  urlExpiresAt: string;
}

/**
 * Backend response shape (snake_case)
 */
export interface WalletDocumentResponse {
  id: string;
  user_id: string;
  wallet_type: WalletType;
  trip_id: string | null;
  document_type: DocumentType;
  name: string;
  description: string | null;
  storage_path: string;
  mime_type: string;
  file_size: number;
  metadata: Record<string, unknown>;
  created_at: string;
  updated_at: string;
}
```

**Why this approach:**
- Separate metadata types for type safety when working with specific document types
- Union type allows flexibility while still providing structure
- Backend response type enables proper adapter transformation
- Filters type supports flexible querying
- Follows existing Trip type patterns (camelCase frontend, snake_case backend)

**Verification:**
- [ ] Types compile without errors
- [ ] Covers all document types from research
- [ ] Matches database schema from Plan 01-01
- [ ] TypeScript strict mode passes

---

### Task 3: Create document normalizer adapter

**What:** Transform backend snake_case data to frontend camelCase

**File:** `src/features/wallet/adapters/normalizeDocument.ts`

**Implementation:**
```typescript
// src/features/wallet/adapters/normalizeDocument.ts
// Transform backend wallet document data to frontend shape

import { WalletDocument, WalletDocumentResponse, DocumentMetadata } from '../types';

/**
 * Normalizes a backend wallet document response to frontend format.
 * Handles snake_case to camelCase conversion and provides defaults.
 *
 * @param response - Raw backend response
 * @returns Normalized WalletDocument
 */
export function normalizeDocument(response: WalletDocumentResponse): WalletDocument {
  return {
    id: response.id,
    userId: response.user_id,
    walletType: response.wallet_type,
    tripId: response.trip_id ?? undefined,
    documentType: response.document_type,
    name: response.name,
    description: response.description ?? undefined,
    storagePath: response.storage_path,
    mimeType: response.mime_type,
    fileSize: response.file_size,
    metadata: normalizeMetadata(response.metadata),
    createdAt: response.created_at,
    updatedAt: response.updated_at,
  };
}

/**
 * Normalizes metadata, ensuring it's a valid object
 */
function normalizeMetadata(metadata: Record<string, unknown> | null): DocumentMetadata {
  if (!metadata || typeof metadata !== 'object') {
    return {};
  }

  // Convert snake_case keys to camelCase if present
  const normalized: Record<string, unknown> = {};

  for (const [key, value] of Object.entries(metadata)) {
    const camelKey = key.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());
    normalized[camelKey] = value;
  }

  return normalized;
}

/**
 * Normalizes an array of documents
 */
export function normalizeDocuments(responses: WalletDocumentResponse[]): WalletDocument[] {
  return responses.map(normalizeDocument);
}
```

**Why this approach:**
- Follows `normalizeTrip` pattern from trips feature
- Handles null → undefined conversion for optional fields
- Recursive metadata normalization for nested objects
- Pure function, easy to test
- Array helper for batch operations

**Verification:**
- [ ] Correctly converts snake_case to camelCase
- [ ] Handles null values appropriately
- [ ] Metadata keys converted
- [ ] Returns valid WalletDocument type

---

### Task 4: Create Zustand store skeleton

**What:** Set up the wallet store with state structure and placeholder actions

**File:** `src/features/wallet/store.ts`

**Implementation:**
```typescript
// src/features/wallet/store.ts
// Zustand store for wallet document management

import { create } from 'zustand';
import { devtools } from 'zustand/middleware';
import {
  WalletDocument,
  WalletType,
  DocumentType,
  CreateDocumentInput,
  UpdateDocumentInput,
  DocumentFilters,
} from './types';
import { logger } from '@/src/utils/logger';

/**
 * Wallet store state interface
 */
interface WalletState {
  // Personal wallet state
  personalDocuments: WalletDocument[];
  personalLoading: boolean;
  personalError: string | null;

  // Group wallet state (per trip)
  groupDocuments: Record<string, WalletDocument[]>;  // tripId -> documents
  groupLoading: boolean;
  groupError: string | null;

  // Selected document (for viewing/editing)
  selectedDocument: WalletDocument | null;

  // Upload state
  uploadProgress: number | null;
  uploadError: string | null;

  // Actions - Personal Wallet
  fetchPersonalDocuments: (filters?: DocumentFilters) => Promise<void>;
  getPersonalDocumentsByType: (type: DocumentType) => WalletDocument[];

  // Actions - Group Wallet
  fetchGroupDocuments: (tripId: string, filters?: DocumentFilters) => Promise<void>;
  getGroupDocuments: (tripId: string) => WalletDocument[];

  // Actions - CRUD (implemented in Phase 2)
  createDocument: (input: CreateDocumentInput) => Promise<WalletDocument>;
  updateDocument: (id: string, input: UpdateDocumentInput) => Promise<WalletDocument>;
  deleteDocument: (id: string) => Promise<void>;

  // Actions - Selection
  setSelectedDocument: (document: WalletDocument | null) => void;

  // Actions - Upload (implemented in Phase 2)
  uploadDocument: (input: CreateDocumentInput) => Promise<WalletDocument>;
  cancelUpload: () => void;

  // Real-time event handling
  handleDocumentEvent: (event: unknown) => void;

  // Utility
  clearError: () => void;
  reset: () => void;
}

/**
 * Initial state values
 */
const initialState = {
  personalDocuments: [],
  personalLoading: false,
  personalError: null,
  groupDocuments: {},
  groupLoading: false,
  groupError: null,
  selectedDocument: null,
  uploadProgress: null,
  uploadError: null,
};

/**
 * Wallet store implementation
 */
export const useWalletStore = create<WalletState>()(
  devtools(
    (set, get) => ({
      ...initialState,

      // ==========================================
      // Personal Wallet Actions
      // ==========================================

      fetchPersonalDocuments: async (filters?: DocumentFilters) => {
        set({ personalLoading: true, personalError: null });
        logger.info('WALLET', 'fetchPersonalDocuments started', { filters });

        try {
          // TODO: Implement API call in Phase 2
          // const response = await api.get(API_PATHS.wallet.personal, { params: filters });
          // const documents = normalizeDocuments(response.data);
          // set({ personalDocuments: documents, personalLoading: false });

          // Placeholder - remove in Phase 2
          set({ personalDocuments: [], personalLoading: false });
          logger.info('WALLET', 'fetchPersonalDocuments completed (placeholder)');
        } catch (error) {
          const message = error instanceof Error ? error.message : 'Failed to fetch personal documents';
          logger.error('WALLET', 'fetchPersonalDocuments error:', message);
          set({ personalError: message, personalLoading: false });
          throw error;
        }
      },

      getPersonalDocumentsByType: (type: DocumentType) => {
        return get().personalDocuments.filter((doc) => doc.documentType === type);
      },

      // ==========================================
      // Group Wallet Actions
      // ==========================================

      fetchGroupDocuments: async (tripId: string, filters?: DocumentFilters) => {
        set({ groupLoading: true, groupError: null });
        logger.info('WALLET', 'fetchGroupDocuments started', { tripId, filters });

        try {
          // TODO: Implement API call in Phase 2
          // const response = await api.get(API_PATHS.wallet.group(tripId), { params: filters });
          // const documents = normalizeDocuments(response.data);
          // set((state) => ({
          //   groupDocuments: { ...state.groupDocuments, [tripId]: documents },
          //   groupLoading: false,
          // }));

          // Placeholder - remove in Phase 2
          set((state) => ({
            groupDocuments: { ...state.groupDocuments, [tripId]: [] },
            groupLoading: false,
          }));
          logger.info('WALLET', 'fetchGroupDocuments completed (placeholder)', { tripId });
        } catch (error) {
          const message = error instanceof Error ? error.message : 'Failed to fetch group documents';
          logger.error('WALLET', 'fetchGroupDocuments error:', message);
          set({ groupError: message, groupLoading: false });
          throw error;
        }
      },

      getGroupDocuments: (tripId: string) => {
        return get().groupDocuments[tripId] || [];
      },

      // ==========================================
      // CRUD Actions (Placeholder - Phase 2)
      // ==========================================

      createDocument: async (_input: CreateDocumentInput) => {
        // TODO: Implement in Phase 2
        logger.warn('WALLET', 'createDocument not yet implemented');
        throw new Error('Not implemented');
      },

      updateDocument: async (_id: string, _input: UpdateDocumentInput) => {
        // TODO: Implement in Phase 2
        logger.warn('WALLET', 'updateDocument not yet implemented');
        throw new Error('Not implemented');
      },

      deleteDocument: async (_id: string) => {
        // TODO: Implement in Phase 2
        logger.warn('WALLET', 'deleteDocument not yet implemented');
        throw new Error('Not implemented');
      },

      // ==========================================
      // Selection Actions
      // ==========================================

      setSelectedDocument: (document: WalletDocument | null) => {
        set({ selectedDocument: document });
      },

      // ==========================================
      // Upload Actions (Placeholder - Phase 2)
      // ==========================================

      uploadDocument: async (_input: CreateDocumentInput) => {
        // TODO: Implement in Phase 2
        logger.warn('WALLET', 'uploadDocument not yet implemented');
        throw new Error('Not implemented');
      },

      cancelUpload: () => {
        // TODO: Implement upload cancellation in Phase 2
        set({ uploadProgress: null, uploadError: null });
      },

      // ==========================================
      // Real-time Event Handling
      // ==========================================

      handleDocumentEvent: (event: unknown) => {
        // TODO: Implement event handling for real-time updates
        logger.info('WALLET', 'Document event received', { event });
      },

      // ==========================================
      // Utility Actions
      // ==========================================

      clearError: () => {
        set({ personalError: null, groupError: null, uploadError: null });
      },

      reset: () => {
        set(initialState);
      },
    }),
    { name: 'WalletStore' }
  )
);

/**
 * Selector hooks for common queries
 */
export const usePersonalDocuments = () => useWalletStore((state) => state.personalDocuments);
export const useGroupDocuments = (tripId: string) =>
  useWalletStore((state) => state.groupDocuments[tripId] || []);
export const useWalletLoading = () =>
  useWalletStore((state) => state.personalLoading || state.groupLoading);
export const useWalletError = () =>
  useWalletStore((state) => state.personalError || state.groupError);
```

**Why this approach:**
- Follows `useTripStore` pattern exactly
- Separate state for personal vs group (different access patterns)
- Group documents keyed by tripId for efficient lookup
- Upload state separate for UI feedback
- Devtools enabled for debugging
- Selector hooks for common use cases
- Placeholder actions with clear TODO markers
- Logger integration for debugging

**Verification:**
- [ ] Store creates without errors
- [ ] TypeScript types pass strict mode
- [ ] Devtools shows "WalletStore" in Redux DevTools
- [ ] Selector hooks work correctly
- [ ] Placeholder actions log warnings

---

## Dependencies

- **Requires:** Plan 01-01 (types should match schema)
- **Blocks:** Phase 2 (Upload system needs store structure)

## Acceptance Criteria

1. Feature directory structure matches existing patterns
2. All type definitions compile without errors
3. Normalizer transforms backend data correctly
4. Store skeleton includes all planned actions
5. TypeScript strict mode passes
6. No impact on existing features

## Testing Notes

For Phase 1, verification is primarily structural:
- Types compile
- Store initializes
- No runtime errors

Functional testing (actual API calls, uploads) in Phase 2.

---

*Plan created: 2026-01-10*
*Ready for execution*
