diff --git a/app/(onboarding)/permissions.tsx b/app/(onboarding)/permissions.tsx
index 5f8fa2d..c1d7302 100644
--- a/app/(onboarding)/permissions.tsx
+++ b/app/(onboarding)/permissions.tsx
@@ -2,9 +2,9 @@ import { useCallback, useEffect, useState } from 'react';
 import { StyleSheet, Platform, Linking } from 'react-native';
 import { router } from 'expo-router';
 import * as Location from 'expo-location';
-import * as Notifications from 'expo-notifications';
-import Animated, { 
-  FadeInDown, 
+import Constants from 'expo-constants';
+import Animated, {
+  FadeInDown,
   FadeIn,
   BounceIn,
 } from 'react-native-reanimated';
@@ -14,6 +14,10 @@ import { ThemedView } from '@/components/ThemedView';
 import { ThemedText } from '@/components/ThemedText';
 import { useOnboarding } from '@/src/providers/OnboardingProvider';
 
+// Helper to check if we're on a physical device
+// Push notifications don't work on simulators/emulators
+const isPhysicalDevice = Constants.isDevice === true;
+
 interface PermissionState {
   location: boolean | null;
   notifications: boolean | null;
@@ -24,7 +28,8 @@ export default function PermissionsScreen() {
   const { setFirstTimeDone } = useOnboarding();
   const [permissions, setPermissions] = useState<PermissionState>({
     location: null,
-    notifications: null,
+    // On simulators, mark notifications as "granted" since they can't be tested anyway
+    notifications: isPhysicalDevice ? null : true,
   });
 
   const requestLocationPermission = useCallback(async () => {
@@ -43,7 +48,18 @@ export default function PermissionsScreen() {
   }, []);
 
   const requestNotificationPermission = useCallback(async () => {
+    // Skip on simulators - notifications don't work anyway
+    if (!isPhysicalDevice) {
+      setPermissions(prev => ({
+        ...prev,
+        notifications: true // Auto-grant on simulator
+      }));
+      return;
+    }
+
     try {
+      // Dynamic import to avoid Keychain errors on simulators
+      const Notifications = await import('expo-notifications');
       const { status } = await Notifications.requestPermissionsAsync();
       setPermissions(prev => ({
         ...prev,
@@ -60,14 +76,24 @@ export default function PermissionsScreen() {
   // Check existing permissions on mount
   useEffect(() => {
     async function checkPermissions() {
-      const [locationStatus, notificationStatus] = await Promise.all([
-        Location.getForegroundPermissionsAsync(),
-        Notifications.getPermissionsAsync(),
-      ]);
+      // Check location permission
+      const locationStatus = await Location.getForegroundPermissionsAsync();
+
+      // Check notification permission (only on physical devices)
+      let notificationGranted = true; // Default to true on simulator
+      if (isPhysicalDevice) {
+        try {
+          const Notifications = await import('expo-notifications');
+          const notificationStatus = await Notifications.getPermissionsAsync();
+          notificationGranted = notificationStatus.status === 'granted';
+        } catch {
+          notificationGranted = false;
+        }
+      }
 
       setPermissions({
         location: locationStatus.status === 'granted',
-        notifications: notificationStatus.status === 'granted',
+        notifications: notificationGranted,
       });
     }
 
diff --git a/app/_layout.tsx b/app/_layout.tsx
index 89902fe..290073a 100644
--- a/app/_layout.tsx
+++ b/app/_layout.tsx
@@ -1,23 +1,66 @@
-// app/_layout.tsx (Temporary Test Screen)
+// app/_layout.tsx - Root Layout with Providers
 import React from 'react';
-import { View, Text, Button } from 'react-native';
-import { useTheme } from '@/src/theme/ThemeProvider';
-import { SplashScreen } from 'expo-router';
+import { SplashScreen, Slot } from 'expo-router';
+import { ThemeProvider } from '@/src/theme/ThemeProvider';
+import { PaperProvider } from 'react-native-paper';
+import { GestureHandlerRootView } from 'react-native-gesture-handler';
+import { StyleSheet, LogBox } from 'react-native';
+import Constants from 'expo-constants';
 
-export default function TestScreen() {
-  // Hooks must be called unconditionally at the top level
-  const { theme, mode, toggleColorScheme } = useTheme();
+// Suppress known simulator-only errors
+// expo-notifications causes Keychain errors on iOS simulators because push notifications
+// don't work on simulators - this is expected and non-fatal
+// Reference: https://docs.expo.dev/push-notifications/faq/
+if (Constants.isDevice !== true) {
+  // On simulator, ignore the Keychain access error from expo-notifications
+  LogBox.ignoreLogs([
+    'Keychain access failed',
+    'getRegistrationInfoAsync',
+    'A required entitlement isn\'t present',
+  ]);
 
-  // Hide splash screen ASAP
+  // Also suppress the error in the console
+  const originalConsoleError = console.error;
+  console.error = (...args: unknown[]) => {
+    const message = args[0];
+    if (
+      typeof message === 'string' &&
+      (message.includes('Keychain access failed') ||
+       message.includes('getRegistrationInfoAsync') ||
+       message.includes("A required entitlement isn't present"))
+    ) {
+      // Silently ignore this expected simulator error
+      return;
+    }
+    originalConsoleError(...args);
+  };
+}
+
+// Keep splash screen visible until we're ready
+SplashScreen.preventAutoHideAsync();
+
+export default function RootLayout() {
   React.useEffect(() => {
-    SplashScreen.hideAsync();
+    // Hide splash screen after a short delay to ensure providers are ready
+    const timer = setTimeout(() => {
+      SplashScreen.hideAsync();
+    }, 100);
+    return () => clearTimeout(timer);
   }, []);
 
   return (
-    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: theme.colors.background.default }}>
-      <Text style={{ color: theme.colors.content.primary }}>Theme mode: {mode}</Text>
-      <Text style={{ color: theme.colors.content.primary }}>Test Screen: Theme loaded!</Text>
-      <Button title="Toggle Theme" onPress={toggleColorScheme} />
-    </View>
+    <GestureHandlerRootView style={styles.container}>
+      <PaperProvider>
+        <ThemeProvider>
+          <Slot />
+        </ThemeProvider>
+      </PaperProvider>
+    </GestureHandlerRootView>
   );
 }
+
+const styles = StyleSheet.create({
+  container: {
+    flex: 1,
+  },
+});
diff --git a/app/index.tsx b/app/index.tsx
index d1d4aa7..19c9fb9 100644
--- a/app/index.tsx
+++ b/app/index.tsx
@@ -1,39 +1,37 @@
-// app/index.tsx (Temporary Minimal Version for Testing)
+// app/index.tsx - Home Screen
 import React from 'react';
-import { Stack, SplashScreen } from 'expo-router';
-import { ThemeProvider, useTheme } from '@/src/theme/ThemeProvider';
-import { View, Text, Button } from 'react-native';
-import { PaperProvider } from 'react-native-paper';
+import { View, Text, Button, StyleSheet } from 'react-native';
+import { useTheme } from '@/src/theme/ThemeProvider';
 
-// Keep splash screen visible initially
-SplashScreen.preventAutoHideAsync();
-
-function TestScreen() {
-  // Hooks must be called unconditionally at the top level
+export default function HomeScreen() {
   const { theme, mode, toggleColorScheme } = useTheme();
 
-  // Hide splash if theme is accessible
-  React.useEffect(() => {
-    SplashScreen.hideAsync();
-  }, []);
-
   return (
-    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: theme.colors.background.default }}>
-      <Text style={{ color: theme.colors.content.primary }}>Theme mode: {mode}</Text>
-      <Text style={{ color: theme.colors.content.primary }}>Test Screen: Theme loaded!</Text>
+    <View style={[styles.container, { backgroundColor: theme.colors.background.default }]}>
+      <Text style={[styles.title, { color: theme.colors.content.primary }]}>
+        NomadCrew
+      </Text>
+      <Text style={[styles.subtitle, { color: theme.colors.content.secondary }]}>
+        Theme mode: {mode}
+      </Text>
       <Button title="Toggle Theme" onPress={toggleColorScheme} />
     </View>
   );
 }
 
-export default function MinimalRootLayout() {
-  return (
-    <PaperProvider>
-      <ThemeProvider>
-        <Stack>
-          <Stack.Screen name="index" component={TestScreen} options={{ title: 'Test' }} />
-        </Stack>
-      </ThemeProvider>
-    </PaperProvider>
-  );
-}
+const styles = StyleSheet.create({
+  container: {
+    flex: 1,
+    justifyContent: 'center',
+    alignItems: 'center',
+  },
+  title: {
+    fontSize: 24,
+    fontWeight: 'bold',
+    marginBottom: 8,
+  },
+  subtitle: {
+    fontSize: 16,
+    marginBottom: 16,
+  },
+});
diff --git a/babel.config.js b/babel.config.js
index e754101..9406afc 100644
--- a/babel.config.js
+++ b/babel.config.js
@@ -2,13 +2,13 @@ module.exports = function (api) {
   api.cache(true);
   return {
     presets: [
-      'babel-preset-expo',       // Expo preset for React Native
+      ['babel-preset-expo', { unstable_transformImportMeta: true }], // Enable import.meta polyfill for Hermes
       '@babel/preset-react',     // React preset for JSX
       '@babel/preset-typescript' // TypeScript support
     ],
     plugins: [
       ['@babel/plugin-transform-react-jsx', { runtime: 'automatic' }], // Ensures automatic JSX runtime
-      'react-native-reanimated/plugin' 
+      'react-native-reanimated/plugin'
     ],
   };
 };
\ No newline at end of file
diff --git a/package-lock.json b/package-lock.json
index 9bfe909..cc9cf5b 100644
--- a/package-lock.json
+++ b/package-lock.json
@@ -19,12 +19,14 @@
         "@rneui/base": "^4.0.0-rc.8",
         "@rneui/themed": "^4.0.0-rc.8",
         "@shopify/flash-list": "2.0.2",
-        "@supabase/supabase-js": "^2.47.10",
+        "@supabase/supabase-js": "^2.86.2",
         "axios": "^1.7.7",
         "base64-js": "^1.5.1",
+        "buffer": "^6.0.3",
         "crypto-js": "^4.2.0",
         "date-fns": "^4.1.0",
         "eventemitter3": "^5.0.1",
+        "events": "^3.3.0",
         "expo": "^54.0.25",
         "expo-apple-authentication": "~8.0.7",
         "expo-auth-session": "~7.0.9",
@@ -32,7 +34,8 @@
         "expo-build-properties": "~1.0.9",
         "expo-constants": "~18.0.10",
         "expo-crypto": "~15.0.7",
-        "expo-dev-client": "~6.0.18",
+        "expo-dev-client": "~6.0.19",
+        "expo-device": "~8.0.9",
         "expo-font": "~14.0.9",
         "expo-google-places-autocomplete": "^1.2.0",
         "expo-haptics": "~15.0.7",
@@ -73,6 +76,7 @@
         "react-native-web": "^0.21.0",
         "react-native-webview": "13.15.0",
         "react-native-worklets": "0.5.1",
+        "stream-browserify": "^3.0.0",
         "zod": "^3.24.2",
         "zustand": "^5.0.1"
       },
@@ -2466,27 +2470,6 @@
         }
       }
     },
-    "node_modules/@expo/mcp-tunnel/node_modules/ws": {
-      "version": "8.18.3",
-      "resolved": "https://registry.npmjs.org/ws/-/ws-8.18.3.tgz",
-      "integrity": "sha512-PEIGCY5tSlUt50cqyMXfCzX+oOPqN0vuGqWzbcJ2xvnkzkq46oOpz7dQaTDBdfICb4N14+GARUDw2XV2N4tvzg==",
-      "license": "MIT",
-      "engines": {
-        "node": ">=10.0.0"
-      },
-      "peerDependencies": {
-        "bufferutil": "^4.0.1",
-        "utf-8-validate": ">=5.0.2"
-      },
-      "peerDependenciesMeta": {
-        "bufferutil": {
-          "optional": true
-        },
-        "utf-8-validate": {
-          "optional": true
-        }
-      }
-    },
     "node_modules/@expo/metro": {
       "version": "54.1.0",
       "resolved": "https://registry.npmjs.org/@expo/metro/-/metro-54.1.0.tgz",
@@ -4901,77 +4884,83 @@
       }
     },
     "node_modules/@supabase/auth-js": {
-      "version": "2.67.3",
-      "resolved": "https://registry.npmjs.org/@supabase/auth-js/-/auth-js-2.67.3.tgz",
-      "integrity": "sha512-NJDaW8yXs49xMvWVOkSIr8j46jf+tYHV0wHhrwOaLLMZSFO4g6kKAf+MfzQ2RaD06OCUkUHIzctLAxjTgEVpzw==",
+      "version": "2.86.2",
+      "resolved": "https://registry.npmjs.org/@supabase/auth-js/-/auth-js-2.86.2.tgz",
+      "integrity": "sha512-7k8IAhgSnZuD9Zex2+ohHKY3aWGDd4ls0xlxMGl3/jPyHSSXrIYfmtJyUH0+DPd4B3psBqHC0Ev0/nZEHdW58w==",
       "license": "MIT",
       "dependencies": {
-        "@supabase/node-fetch": "^2.6.14"
+        "tslib": "2.8.1"
+      },
+      "engines": {
+        "node": ">=20.0.0"
       }
     },
     "node_modules/@supabase/functions-js": {
-      "version": "2.4.4",
-      "resolved": "https://registry.npmjs.org/@supabase/functions-js/-/functions-js-2.4.4.tgz",
-      "integrity": "sha512-WL2p6r4AXNGwop7iwvul2BvOtuJ1YQy8EbOd0dhG1oN1q8el/BIRSFCFnWAMM/vJJlHWLi4ad22sKbKr9mvjoA==",
+      "version": "2.86.2",
+      "resolved": "https://registry.npmjs.org/@supabase/functions-js/-/functions-js-2.86.2.tgz",
+      "integrity": "sha512-OLpy3NIlj7q3yGMFwUpPkDPJbRx4aU+u73SiXqiMnA5ARwzVcOReSzI2u4oOqioE+3ud0fRx7sRsfoklBwYOmg==",
       "license": "MIT",
       "dependencies": {
-        "@supabase/node-fetch": "^2.6.14"
-      }
-    },
-    "node_modules/@supabase/node-fetch": {
-      "version": "2.6.15",
-      "resolved": "https://registry.npmjs.org/@supabase/node-fetch/-/node-fetch-2.6.15.tgz",
-      "integrity": "sha512-1ibVeYUacxWYi9i0cf5efil6adJ9WRyZBLivgjs+AUpewx1F3xPi7gLgaASI2SmIQxPoCEjAsLAzKPgMJVgOUQ==",
-      "license": "MIT",
-      "dependencies": {
-        "whatwg-url": "^5.0.0"
+        "tslib": "2.8.1"
       },
       "engines": {
-        "node": "4.x || >=6.0.0"
+        "node": ">=20.0.0"
       }
     },
     "node_modules/@supabase/postgrest-js": {
-      "version": "1.17.7",
-      "resolved": "https://registry.npmjs.org/@supabase/postgrest-js/-/postgrest-js-1.17.7.tgz",
-      "integrity": "sha512-aOzOYaTADm/dVTNksyqv9KsbhVa1gHz1Hoxb2ZEF2Ed9H7qlWOfptECQWmkEmrrFjtNaiPrgiSaPECvzI/seDA==",
+      "version": "2.86.2",
+      "resolved": "https://registry.npmjs.org/@supabase/postgrest-js/-/postgrest-js-2.86.2.tgz",
+      "integrity": "sha512-KVgOF2QASvUfQnzMGAmxR7f3ZF/eZ8PFp2F5Q7SAPQlmB83FEaZ7C/QMzfVXXqkMbotfh96xcaBNSKnxowFObA==",
       "license": "MIT",
       "dependencies": {
-        "@supabase/node-fetch": "^2.6.14"
+        "tslib": "2.8.1"
+      },
+      "engines": {
+        "node": ">=20.0.0"
       }
     },
     "node_modules/@supabase/realtime-js": {
-      "version": "2.11.2",
-      "resolved": "https://registry.npmjs.org/@supabase/realtime-js/-/realtime-js-2.11.2.tgz",
-      "integrity": "sha512-u/XeuL2Y0QEhXSoIPZZwR6wMXgB+RQbJzG9VErA3VghVt7uRfSVsjeqd7m5GhX3JR6dM/WRmLbVR8URpDWG4+w==",
+      "version": "2.86.2",
+      "resolved": "https://registry.npmjs.org/@supabase/realtime-js/-/realtime-js-2.86.2.tgz",
+      "integrity": "sha512-uLUYrOMeK1qXHISxdMFVfBs0sGV5PmqYewIHvLBnMYbb//LERojxfKlVSJBgZ+aAwxANmtQKcprjGZI7DJ6lNQ==",
       "license": "MIT",
       "dependencies": {
-        "@supabase/node-fetch": "^2.6.14",
-        "@types/phoenix": "^1.5.4",
-        "@types/ws": "^8.5.10",
-        "ws": "^8.18.0"
+        "@types/phoenix": "^1.6.6",
+        "@types/ws": "^8.18.1",
+        "tslib": "2.8.1",
+        "ws": "^8.18.2"
+      },
+      "engines": {
+        "node": ">=20.0.0"
       }
     },
     "node_modules/@supabase/storage-js": {
-      "version": "2.7.1",
-      "resolved": "https://registry.npmjs.org/@supabase/storage-js/-/storage-js-2.7.1.tgz",
-      "integrity": "sha512-asYHcyDR1fKqrMpytAS1zjyEfvxuOIp1CIXX7ji4lHHcJKqyk+sLl/Vxgm4sN6u8zvuUtae9e4kDxQP2qrwWBA==",
+      "version": "2.86.2",
+      "resolved": "https://registry.npmjs.org/@supabase/storage-js/-/storage-js-2.86.2.tgz",
+      "integrity": "sha512-zyR4PkO7R4f4/xRBVJho3Dm7y4512BoCqGmD7LjNV2GVtWt8vEmambiuMB2Ty3l76mqw+ynQyHY8yFWSERrHXA==",
       "license": "MIT",
       "dependencies": {
-        "@supabase/node-fetch": "^2.6.14"
+        "iceberg-js": "^0.8.0",
+        "tslib": "2.8.1"
+      },
+      "engines": {
+        "node": ">=20.0.0"
       }
     },
     "node_modules/@supabase/supabase-js": {
-      "version": "2.47.10",
-      "resolved": "https://registry.npmjs.org/@supabase/supabase-js/-/supabase-js-2.47.10.tgz",
-      "integrity": "sha512-vJfPF820Ho5WILYHfKiBykDQ1SB9odTHrRZ0JxHfuLMC8GRvv21YLkUZQK7/rSVCkLvD6/ZwMWaOAfdUd//guw==",
+      "version": "2.86.2",
+      "resolved": "https://registry.npmjs.org/@supabase/supabase-js/-/supabase-js-2.86.2.tgz",
+      "integrity": "sha512-KXoiqFf7zZhL/+lj7oBFFUvVDQ6gy03v9wQ5E++f7xiJUuqmI4DuBhrv8uFo6B2EGTQTA3vkXjbxmYIug/zfWw==",
       "license": "MIT",
       "dependencies": {
-        "@supabase/auth-js": "2.67.3",
-        "@supabase/functions-js": "2.4.4",
-        "@supabase/node-fetch": "2.6.15",
-        "@supabase/postgrest-js": "1.17.7",
-        "@supabase/realtime-js": "2.11.2",
-        "@supabase/storage-js": "2.7.1"
+        "@supabase/auth-js": "2.86.2",
+        "@supabase/functions-js": "2.86.2",
+        "@supabase/postgrest-js": "2.86.2",
+        "@supabase/realtime-js": "2.86.2",
+        "@supabase/storage-js": "2.86.2"
+      },
+      "engines": {
+        "node": ">=20.0.0"
       }
     },
     "node_modules/@svgr/babel-plugin-add-jsx-attribute": {
@@ -5652,9 +5641,9 @@
       "license": "MIT"
     },
     "node_modules/@types/ws": {
-      "version": "8.5.13",
-      "resolved": "https://registry.npmjs.org/@types/ws/-/ws-8.5.13.tgz",
-      "integrity": "sha512-osM/gWBTPKgHV8XkTunnegTRIsvF6owmf5w+JtAfOw472dptdm0dlGv4xCt6GwQRcC2XVOvvRE/0bAoQcL2QkA==",
+      "version": "8.18.1",
+      "resolved": "https://registry.npmjs.org/@types/ws/-/ws-8.18.1.tgz",
+      "integrity": "sha512-ThVF6DCVhA8kUGy+aazFQ4kXQ7E1Ty7A3ypFOe0IcJV8O/M511G99AW24irKrW56Wt44yG9+ij8FaqoBGkuBXg==",
       "license": "MIT",
       "dependencies": {
         "@types/node": "*"
@@ -7014,9 +7003,9 @@
       }
     },
     "node_modules/buffer": {
-      "version": "5.7.1",
-      "resolved": "https://registry.npmjs.org/buffer/-/buffer-5.7.1.tgz",
-      "integrity": "sha512-EHcyIPBQ4BSGlvjB16k5KgAJ27CIsHY/2JBmCRReo48y9rQ3MaUzWX3KVlBa4U7MyX02HdVj0K7C3WaB3ju7FQ==",
+      "version": "6.0.3",
+      "resolved": "https://registry.npmjs.org/buffer/-/buffer-6.0.3.tgz",
+      "integrity": "sha512-FTiCpNxtwiZZHEZbcbTIcZjERVICn9yq/pDFkTl95/AxzD1naBctN7YO68riM/gLSDY7sdrMby8hofADYuuqOA==",
       "funding": [
         {
           "type": "github",
@@ -7034,7 +7023,7 @@
       "license": "MIT",
       "dependencies": {
         "base64-js": "^1.3.1",
-        "ieee754": "^1.1.13"
+        "ieee754": "^1.2.1"
       }
     },
     "node_modules/buffer-from": {
@@ -9344,6 +9333,15 @@
       "integrity": "sha512-GWkBvjiSZK87ELrYOSESUYeVIc9mvLLf/nXalMOS5dYrgZq9o5OVkbZAVM06CVxYsCwH9BDZFPlQTlPA1j4ahA==",
       "license": "MIT"
     },
+    "node_modules/events": {
+      "version": "3.3.0",
+      "resolved": "https://registry.npmjs.org/events/-/events-3.3.0.tgz",
+      "integrity": "sha512-mQw+2fkQbALzQ7V0MY0IqdnXNOeTtP4r0lN9z7AAawCXgqea7bDii20AYrIBrFd/Hx0M2Ocz6S111CaFkUcb0Q==",
+      "license": "MIT",
+      "engines": {
+        "node": ">=0.8.x"
+      }
+    },
     "node_modules/exec-async": {
       "version": "2.2.0",
       "resolved": "https://registry.npmjs.org/exec-async/-/exec-async-2.2.0.tgz",
@@ -9543,13 +9541,13 @@
       }
     },
     "node_modules/expo-dev-client": {
-      "version": "6.0.18",
-      "resolved": "https://registry.npmjs.org/expo-dev-client/-/expo-dev-client-6.0.18.tgz",
-      "integrity": "sha512-8QKWvhsoZpMkecAMlmWoRHnaTNiPS3aO7E42spZOMjyiaNRJMHZsnB8W2b63dt3Yg3oLyskLAoI8IOmnqVX8vA==",
+      "version": "6.0.19",
+      "resolved": "https://registry.npmjs.org/expo-dev-client/-/expo-dev-client-6.0.19.tgz",
+      "integrity": "sha512-aribQ9JVa2N9wo1GNDaf5U91EPQ2jWkowxgdp0dDDREe6uJMmB3v+HQeVqxGvTgbUuwt2qMNgBcPisQviwInvA==",
       "license": "MIT",
       "dependencies": {
-        "expo-dev-launcher": "6.0.18",
-        "expo-dev-menu": "7.0.17",
+        "expo-dev-launcher": "6.0.19",
+        "expo-dev-menu": "7.0.18",
         "expo-dev-menu-interface": "2.0.0",
         "expo-manifests": "~1.0.9",
         "expo-updates-interface": "~2.0.0"
@@ -9559,12 +9557,13 @@
       }
     },
     "node_modules/expo-dev-launcher": {
-      "version": "6.0.18",
-      "resolved": "https://registry.npmjs.org/expo-dev-launcher/-/expo-dev-launcher-6.0.18.tgz",
-      "integrity": "sha512-JTtcIfNvHO9PTdRJLmHs+7HJILXXZjF95jxgzu6hsJrgsTg/AZDtEsIt/qa6ctEYQTqrLdsLDgDhiXVel3AoQA==",
+      "version": "6.0.19",
+      "resolved": "https://registry.npmjs.org/expo-dev-launcher/-/expo-dev-launcher-6.0.19.tgz",
+      "integrity": "sha512-l1dtbv2BiaYdCqpjaNUhQG4wZKyyqMEYDB5Dio5fgJlASy13EuTAmxtur3pbhlFAX9x3MPrbj2u+ytKc9GNY9A==",
       "license": "MIT",
       "dependencies": {
-        "expo-dev-menu": "7.0.17",
+        "ajv": "^8.11.0",
+        "expo-dev-menu": "7.0.18",
         "expo-manifests": "~1.0.9"
       },
       "peerDependencies": {
@@ -9572,9 +9571,9 @@
       }
     },
     "node_modules/expo-dev-menu": {
-      "version": "7.0.17",
-      "resolved": "https://registry.npmjs.org/expo-dev-menu/-/expo-dev-menu-7.0.17.tgz",
-      "integrity": "sha512-NIu7TdaZf+A8+DROa6BB6lDfxjXxwaD+Q8QbNSVa0E0x6yl3P0ZJ80QbD2cCQeBzlx3Ufd3hNhczQWk4+A29HQ==",
+      "version": "7.0.18",
+      "resolved": "https://registry.npmjs.org/expo-dev-menu/-/expo-dev-menu-7.0.18.tgz",
+      "integrity": "sha512-4kTdlHrnZCAWCT6tZRQHSSjZ7vECFisL4T+nsG/GJDo/jcHNaOVGV5qPV9wzlTxyMk3YOPggRw4+g7Ownrg5eA==",
       "license": "MIT",
       "dependencies": {
         "expo-dev-menu-interface": "2.0.0"
@@ -9592,6 +9591,44 @@
         "expo": "*"
       }
     },
+    "node_modules/expo-device": {
+      "version": "8.0.9",
+      "resolved": "https://registry.npmjs.org/expo-device/-/expo-device-8.0.9.tgz",
+      "integrity": "sha512-XqRpaljDNAYZGZzMpC+b9KZfzfydtkwx3pJAp6ODDH+O/5wjAw+mLc5wQMGJCx8/aqVmMsAokec7iebxDPFZDA==",
+      "license": "MIT",
+      "dependencies": {
+        "ua-parser-js": "^0.7.33"
+      },
+      "peerDependencies": {
+        "expo": "*"
+      }
+    },
+    "node_modules/expo-device/node_modules/ua-parser-js": {
+      "version": "0.7.41",
+      "resolved": "https://registry.npmjs.org/ua-parser-js/-/ua-parser-js-0.7.41.tgz",
+      "integrity": "sha512-O3oYyCMPYgNNHuO7Jjk3uacJWZF8loBgwrfd/5LE/HyZ3lUIOdniQ7DNXJcIgZbwioZxk0fLfI4EVnetdiX5jg==",
+      "funding": [
+        {
+          "type": "opencollective",
+          "url": "https://opencollective.com/ua-parser-js"
+        },
+        {
+          "type": "paypal",
+          "url": "https://paypal.me/faisalman"
+        },
+        {
+          "type": "github",
+          "url": "https://github.com/sponsors/faisalman"
+        }
+      ],
+      "license": "MIT",
+      "bin": {
+        "ua-parser-js": "script/cli.js"
+      },
+      "engines": {
+        "node": "*"
+      }
+    },
     "node_modules/expo-file-system": {
       "version": "19.0.19",
       "resolved": "https://registry.npmjs.org/expo-file-system/-/expo-file-system-19.0.19.tgz",
@@ -10776,6 +10813,15 @@
       "integrity": "sha512-WDC/ui2VVRrz3jOVi+XtjqkDjiVjTtFaAGiW37k6b+ohyQ5wYDOGkvCZa8+H0nx3gyvv0+BST9xuOgIyGQ00gw==",
       "license": "BSD-3-Clause"
     },
+    "node_modules/iceberg-js": {
+      "version": "0.8.0",
+      "resolved": "https://registry.npmjs.org/iceberg-js/-/iceberg-js-0.8.0.tgz",
+      "integrity": "sha512-kmgmea2nguZEvRqW79gDqNXyxA3OS5WIgMVffrHpqXV4F/J4UmNIw2vstixioLTNSkd5rFB8G0s3Lwzogm6OFw==",
+      "license": "MIT",
+      "engines": {
+        "node": ">=20.0.0"
+      }
+    },
     "node_modules/iconv-lite": {
       "version": "0.6.3",
       "resolved": "https://registry.npmjs.org/iconv-lite/-/iconv-lite-0.6.3.tgz",
@@ -15660,6 +15706,20 @@
       "dev": true,
       "license": "MIT"
     },
+    "node_modules/readable-stream": {
+      "version": "3.6.2",
+      "resolved": "https://registry.npmjs.org/readable-stream/-/readable-stream-3.6.2.tgz",
+      "integrity": "sha512-9u/sniCrY3D5WdsERHzHE4G2YCXqoG5FTHUiCC4SIbr6XcLZBY05ya9EKjYek9O5xOAwjGq+1JdGBAS7Q9ScoA==",
+      "license": "MIT",
+      "dependencies": {
+        "inherits": "^2.0.3",
+        "string_decoder": "^1.1.1",
+        "util-deprecate": "^1.0.1"
+      },
+      "engines": {
+        "node": ">= 6"
+      }
+    },
     "node_modules/redent": {
       "version": "3.0.0",
       "resolved": "https://registry.npmjs.org/redent/-/redent-3.0.0.tgz",
@@ -16704,6 +16764,16 @@
         "node": ">= 0.6"
       }
     },
+    "node_modules/stream-browserify": {
+      "version": "3.0.0",
+      "resolved": "https://registry.npmjs.org/stream-browserify/-/stream-browserify-3.0.0.tgz",
+      "integrity": "sha512-H73RAHsVBapbim0tU2JwwOiXUj+fikfiaoYAKHF3VJfA0pe2BCzkhAHBlLG6REzE+2WNZcxOXjK7lkso+9euLA==",
+      "license": "MIT",
+      "dependencies": {
+        "inherits": "~2.0.4",
+        "readable-stream": "^3.5.0"
+      }
+    },
     "node_modules/stream-buffers": {
       "version": "2.2.0",
       "resolved": "https://registry.npmjs.org/stream-buffers/-/stream-buffers-2.2.0.tgz",
@@ -16722,6 +16792,15 @@
         "node": ">=4"
       }
     },
+    "node_modules/string_decoder": {
+      "version": "1.3.0",
+      "resolved": "https://registry.npmjs.org/string_decoder/-/string_decoder-1.3.0.tgz",
+      "integrity": "sha512-hkRX8U1WjJFd8LsDJ2yQ/wWWxaopEsABU1XfkM8A+j0+85JAGppt16cr1Whg6KIbb4okU6Mql6BOj+uup/wKeA==",
+      "license": "MIT",
+      "dependencies": {
+        "safe-buffer": "~5.2.0"
+      }
+    },
     "node_modules/string-length": {
       "version": "4.0.2",
       "resolved": "https://registry.npmjs.org/string-length/-/string-length-4.0.2.tgz",
@@ -17779,6 +17858,12 @@
         "which-typed-array": "^1.1.2"
       }
     },
+    "node_modules/util-deprecate": {
+      "version": "1.0.2",
+      "resolved": "https://registry.npmjs.org/util-deprecate/-/util-deprecate-1.0.2.tgz",
+      "integrity": "sha512-EPD5q1uXyFxJpCrLnCc1nHnq3gOa6DZBocAIiI2TaSCA7VCJ1UJDMagCzIkXNsUYfD1daK//LTEQ8xiIbrHtcw==",
+      "license": "MIT"
+    },
     "node_modules/utils-merge": {
       "version": "1.0.1",
       "resolved": "https://registry.npmjs.org/utils-merge/-/utils-merge-1.0.1.tgz",
@@ -17950,6 +18035,30 @@
         "node": ">=10"
       }
     },
+    "node_modules/whatwg-url-without-unicode/node_modules/buffer": {
+      "version": "5.7.1",
+      "resolved": "https://registry.npmjs.org/buffer/-/buffer-5.7.1.tgz",
+      "integrity": "sha512-EHcyIPBQ4BSGlvjB16k5KgAJ27CIsHY/2JBmCRReo48y9rQ3MaUzWX3KVlBa4U7MyX02HdVj0K7C3WaB3ju7FQ==",
+      "funding": [
+        {
+          "type": "github",
+          "url": "https://github.com/sponsors/feross"
+        },
+        {
+          "type": "patreon",
+          "url": "https://www.patreon.com/feross"
+        },
+        {
+          "type": "consulting",
+          "url": "https://feross.org/support"
+        }
+      ],
+      "license": "MIT",
+      "dependencies": {
+        "base64-js": "^1.3.1",
+        "ieee754": "^1.1.13"
+      }
+    },
     "node_modules/whatwg-url-without-unicode/node_modules/webidl-conversions": {
       "version": "5.0.0",
       "resolved": "https://registry.npmjs.org/webidl-conversions/-/webidl-conversions-5.0.0.tgz",
@@ -18125,9 +18234,9 @@
       "license": "ISC"
     },
     "node_modules/ws": {
-      "version": "8.18.0",
-      "resolved": "https://registry.npmjs.org/ws/-/ws-8.18.0.tgz",
-      "integrity": "sha512-8VbfWfHLbbwu3+N6OKsOMpBdT4kXPDDB9cJk2bJ6mh9ucxdlnNvH1e+roYkKmN9Nxw2yjz7VzeO9oOz2zJ04Pw==",
+      "version": "8.18.3",
+      "resolved": "https://registry.npmjs.org/ws/-/ws-8.18.3.tgz",
+      "integrity": "sha512-PEIGCY5tSlUt50cqyMXfCzX+oOPqN0vuGqWzbcJ2xvnkzkq46oOpz7dQaTDBdfICb4N14+GARUDw2XV2N4tvzg==",
       "license": "MIT",
       "engines": {
         "node": ">=10.0.0"
diff --git a/package.json b/package.json
index df0bdf1..766032d 100644
--- a/package.json
+++ b/package.json
@@ -67,12 +67,14 @@
     "@rneui/base": "^4.0.0-rc.8",
     "@rneui/themed": "^4.0.0-rc.8",
     "@shopify/flash-list": "2.0.2",
-    "@supabase/supabase-js": "^2.47.10",
+    "@supabase/supabase-js": "^2.86.2",
     "axios": "^1.7.7",
     "base64-js": "^1.5.1",
+    "buffer": "^6.0.3",
     "crypto-js": "^4.2.0",
     "date-fns": "^4.1.0",
     "eventemitter3": "^5.0.1",
+    "events": "^3.3.0",
     "expo": "^54.0.25",
     "expo-apple-authentication": "~8.0.7",
     "expo-auth-session": "~7.0.9",
@@ -80,7 +82,8 @@
     "expo-build-properties": "~1.0.9",
     "expo-constants": "~18.0.10",
     "expo-crypto": "~15.0.7",
-    "expo-dev-client": "~6.0.18",
+    "expo-dev-client": "~6.0.19",
+    "expo-device": "~8.0.9",
     "expo-font": "~14.0.9",
     "expo-google-places-autocomplete": "^1.2.0",
     "expo-haptics": "~15.0.7",
@@ -121,6 +124,7 @@
     "react-native-web": "^0.21.0",
     "react-native-webview": "13.15.0",
     "react-native-worklets": "0.5.1",
+    "stream-browserify": "^3.0.0",
     "zod": "^3.24.2",
     "zustand": "^5.0.1"
   },
diff --git a/src/auth/supabaseClient.ts b/src/auth/supabaseClient.ts
index 9c3e18a..f1b2de8 100644
--- a/src/auth/supabaseClient.ts
+++ b/src/auth/supabaseClient.ts
@@ -10,11 +10,11 @@ if (!supabaseUrl || !supabaseAnonKey) {
 
 export const supabase = createClient(supabaseUrl, supabaseAnonKey, {
   auth: {
+    storage: AsyncStorage,
     autoRefreshToken: true,
     persistSession: true,
-    detectSessionInUrl: false,
-    storage: AsyncStorage
-  },
+    detectSessionInUrl: false
+  }
 });
 
 export default supabase;
diff --git a/src/hooks/useTestNotifications.ts b/src/hooks/useTestNotifications.ts
index c0c23ef..aee94a4 100644
--- a/src/hooks/useTestNotifications.ts
+++ b/src/hooks/useTestNotifications.ts
@@ -1,13 +1,13 @@
 import { useNotificationStore } from '../store/useNotificationStore';
 import { useCallback } from 'react';
-import { v4 as uuidv4 } from 'uuid';
+import * as Crypto from 'expo-crypto';
 
 export const useTestNotifications = () => {
   const { addNotification } = useNotificationStore();
   
   const addTripInviteNotification = useCallback(() => {
-    const inviteId = uuidv4();
-    const tripId = uuidv4();
+    const inviteId = Crypto.randomUUID();
+    const tripId = Crypto.randomUUID();
     
     addNotification({
       id: inviteId,
@@ -24,7 +24,7 @@ export const useTestNotifications = () => {
   
   const addSystemNotification = useCallback(() => {
     addNotification({
-      id: uuidv4(),
+      id: Crypto.randomUUID(),
       type: 'SYSTEM',
       title: 'System Notification',
       message: 'This is a test system notification.',
@@ -35,15 +35,15 @@ export const useTestNotifications = () => {
   
   const addChatNotification = useCallback(() => {
     addNotification({
-      id: uuidv4(),
+      id: Crypto.randomUUID(),
       type: 'CHAT_MESSAGE',
       title: 'New Message',
       message: 'You have a new message from Test User.',
       timestamp: new Date().toISOString(),
       isRead: false,
       data: {
-        userId: uuidv4(),
-        tripId: uuidv4(),
+        userId: Crypto.randomUUID(),
+        tripId: Crypto.randomUUID(),
         userName: 'Test User'
       }
     });
@@ -51,14 +51,14 @@ export const useTestNotifications = () => {
   
   const addTripUpdateNotification = useCallback(() => {
     addNotification({
-      id: uuidv4(),
+      id: Crypto.randomUUID(),
       type: 'TRIP_UPDATE',
       title: 'Trip Updated',
       message: 'Your trip to Barcelona has been updated with new dates.',
       timestamp: new Date().toISOString(),
       isRead: false,
       data: {
-        tripId: uuidv4(),
+        tripId: Crypto.randomUUID(),
         updatedBy: 'Trip Owner'
       }
     });
diff --git a/src/store/useAuthStore.ts b/src/store/useAuthStore.ts
index aa92acd..823db42 100644
--- a/src/store/useAuthStore.ts
+++ b/src/store/useAuthStore.ts
@@ -1,14 +1,15 @@
 import { create } from 'zustand';
+import { subscribeWithSelector } from 'zustand/middleware';
 import { supabase } from '@/src/auth/supabaseClient';
 import type { AuthState, LoginCredentials, RegisterCredentials, User, AuthStatus } from '@/src/types/auth';
 import { Session } from '@supabase/supabase-js';
 import AsyncStorage from '@react-native-async-storage/async-storage';
 import { logger } from '@/src/utils/logger';
-import { authApi } from '@/src/api/auth-api';
-import { ERROR_CODES, ERROR_MESSAGES } from '@/src/api/constants';
+import { ERROR_MESSAGES } from '@/src/api/constants';
 import { registerAuthHandlers } from '@/src/api/api-client';
-import * as Notifications from 'expo-notifications';
+import { Platform } from 'react-native';
 import { api } from '@/src/api/api-client';
+import Constants from 'expo-constants';
 
 // API Error interface for better type safety
 interface ApiError extends Error {
@@ -44,9 +45,11 @@ const recoverSession = async () => {
   return null;
 };
 
-export const useAuthStore = create<AuthState>((set, get) => {
-  // State for user, token, loading, etc.
-  const store = {
+// Use subscribeWithSelector middleware to allow external subscriptions to auth state changes
+// This enables other stores (like notifications) to react when auth status changes
+export const useAuthStore = create<AuthState>()(
+  subscribeWithSelector((set, get) => ({
+    // State for user, token, loading, etc.
     user: null,
     token: null,
     loading: false,
@@ -54,28 +57,30 @@ export const useAuthStore = create<AuthState>((set, get) => {
     isInitialized: false,
     isFirstTime: false,
     isVerifying: false,
-    status: 'unauthenticated' as AuthStatus,
+    // Start with 'idle' - we don't know auth status until we check storage/Supabase
+    status: 'idle' as AuthStatus,
     refreshToken: null,
     pushToken: null,
 
     /**
-     * Called on app start to recover session
+     * Called on app start to recover session (hydration pattern)
+     * Sets status from 'idle' to either 'authenticated' or 'unauthenticated'
      */
     initialize: async () => {
       try {
-        logger.debug('AUTH', 'Initializing auth store');
+        logger.debug('AUTH', 'Initializing auth store (hydrating)');
         const { data: { session }, error } = await supabase.auth.getSession();
 
         if (error || !session) {
           logger.debug('AUTH', 'No valid session found');
-          return set({ isInitialized: true });
+          return set({ isInitialized: true, status: 'unauthenticated' });
         }
 
         logger.debug('AUTH', 'Session restored', {
           userId: session.user.id,
           expiresAt: session.expires_at
         });
-        set({ 
+        set({
           user: {
             id: session.user.id,
             email: session.user.email ?? '',
@@ -86,12 +91,13 @@ export const useAuthStore = create<AuthState>((set, get) => {
           },
           token: session.access_token,
           refreshToken: session.refresh_token,
-          isInitialized: true
+          isInitialized: true,
+          status: 'authenticated'
         });
 
       } catch (error) {
         logger.error('AUTH', 'Initialization error:', error);
-        set({ isInitialized: true });
+        set({ isInitialized: true, status: 'unauthenticated' });
       }
     },
 
@@ -304,8 +310,9 @@ export const useAuthStore = create<AuthState>((set, get) => {
           error: null,
           loading: false,
           isVerifying: false,
+          status: 'authenticated',
         });
-    
+
       } catch (error: unknown) {
         console.error('[Auth] Login failed:', error);
         set({
@@ -387,17 +394,19 @@ export const useAuthStore = create<AuthState>((set, get) => {
           refreshToken: data.session.refresh_token,
           loading: false,
           error: null,
-          isVerifying: false
+          isVerifying: false,
+          status: 'authenticated'
         });
-        
+
         console.log('AUTH: Authentication successful', {
           accessToken: data.session.access_token.substring(0, 10) + '...',
           refreshToken: data.session.refresh_token ? data.session.refresh_token.substring(0, 10) + '...' : 'none'
         });
-      } catch (error: ApiError) {
-        console.error('AUTH: Google sign-in error:', error);
+      } catch (error: unknown) {
+        const err = error as ApiError;
+        console.error('AUTH: Google sign-in error:', err);
         set({
-          error: error.message || 'Google sign-in failed',
+          error: err.message || 'Google sign-in failed',
           loading: false
         });
         throw error;
@@ -428,13 +437,15 @@ export const useAuthStore = create<AuthState>((set, get) => {
           refreshToken: session.refresh_token,
           loading: false,
           error: null,
-          isVerifying: false
+          isVerifying: false,
+          status: 'authenticated'
         });
 
-      } catch (error: ApiError) {
-        console.error('AUTH: Apple sign-in error:', error);
+      } catch (error: unknown) {
+        const err = error as ApiError;
+        console.error('AUTH: Apple sign-in error:', err);
         set({
-          error: error.message || 'Apple sign-in failed',
+          error: err.message || 'Apple sign-in failed',
           loading: false
         });
         throw error;
@@ -500,21 +511,60 @@ export const useAuthStore = create<AuthState>((set, get) => {
       set({ isFirstTime: false });
     },
 
+    /**
+     * Register for push notifications
+     * Uses dynamic import to prevent Keychain errors on iOS simulators
+     * Reference: https://docs.expo.dev/push-notifications/push-notifications-setup/
+     */
     registerPushToken: async () => {
       try {
-        // Check if we already have permission
-        const { status } = await Notifications.getPermissionsAsync();
-        if (status !== 'granted') {
+        // Guard: Push notifications only work on physical devices
+        // Constants.isDevice is false on simulators/emulators
+        if (Constants.isDevice !== true) {
+          logger.debug('AUTH', 'Push notifications skipped: not a physical device (simulator/emulator)');
           return;
         }
 
-        // Get the token
-        const token = await Notifications.getExpoPushTokenAsync({
-          projectId: process.env.EXPO_PUBLIC_PROJECT_ID // Add this to your env
-        });
+        // Dynamic import - only loads on physical devices to avoid Keychain errors
+        const Notifications = await import('expo-notifications');
+
+        // Android 13+ requires notification channel before requesting permissions
+        if (Platform.OS === 'android') {
+          await Notifications.setNotificationChannelAsync('default', {
+            name: 'default',
+            importance: Notifications.AndroidImportance.MAX,
+            vibrationPattern: [0, 250, 250, 250],
+            lightColor: '#FF231F7C',
+          });
+        }
+
+        // Check current permission status
+        const { status: existingStatus } = await Notifications.getPermissionsAsync();
+        let finalStatus = existingStatus;
+
+        // Request permission if not already granted
+        if (existingStatus !== 'granted') {
+          const { status } = await Notifications.requestPermissionsAsync();
+          finalStatus = status;
+        }
+
+        if (finalStatus !== 'granted') {
+          logger.debug('AUTH', 'Push notification permission not granted');
+          return;
+        }
+
+        // Get the Expo push token
+        const projectId = process.env.EXPO_PUBLIC_PROJECT_ID;
+        if (!projectId) {
+          logger.warn('AUTH', 'EXPO_PUBLIC_PROJECT_ID not set, cannot get push token');
+          return;
+        }
+
+        const token = await Notifications.getExpoPushTokenAsync({ projectId });
 
         // Store it locally
         set({ pushToken: token.data });
+        logger.debug('AUTH', 'Push token registered successfully');
 
         // Send it to the backend
         const { user } = get();
@@ -522,19 +572,19 @@ export const useAuthStore = create<AuthState>((set, get) => {
           await api.post('/users/push-token', { token: token.data });
         }
       } catch (error) {
-        console.error('Failed to register push token:', error);
+        // Log but don't throw - push notifications are non-critical
+        logger.error('AUTH', 'Failed to register push token:', error);
       }
-    }
-  };
-
-  // Register auth handlers with the API client
-  registerAuthHandlers({
-    getToken: () => get().token,
-    getRefreshToken: () => get().refreshToken,
-    isInitialized: () => get().isInitialized,
-    refreshSession: async () => await get().refreshSession(),
-    logout: () => get().logout(),
-  });
+    },
+  }))
+);
 
-  return store;
+// Register auth handlers with the API client after store creation
+// This must be done outside the store creation to avoid circular dependencies
+registerAuthHandlers({
+  getToken: () => useAuthStore.getState().token,
+  getRefreshToken: () => useAuthStore.getState().refreshToken,
+  isInitialized: () => useAuthStore.getState().isInitialized,
+  refreshSession: async () => await useAuthStore.getState().refreshSession(),
+  logout: () => useAuthStore.getState().logout(),
 });
\ No newline at end of file
diff --git a/src/store/useChatStore.ts b/src/store/useChatStore.ts
index 9b530d9..34b30f4 100644
--- a/src/store/useChatStore.ts
+++ b/src/store/useChatStore.ts
@@ -8,7 +8,7 @@ import { WebSocketManager } from '@/src/websocket/WebSocketManager';
 import AsyncStorage from '@react-native-async-storage/async-storage';
 import { api } from '@/src/api/api-client';
 import { API_PATHS } from '@/src/utils/api-paths';
-import { v4 as uuidv4 } from 'uuid';
+import * as Crypto from 'expo-crypto';
 import { useEffect } from 'react';
 
 // Constants
@@ -275,7 +275,7 @@ export const useChatStore = create<ChatState>((set, get) => ({
     set({ isSending: true });
     
     // Create an optimistic message with a temporary ID
-    const optimisticId = uuidv4();
+    const optimisticId = Crypto.randomUUID();
     
     const optimisticMessage: ChatMessageWithStatus = {
       message: {
diff --git a/src/store/useNotificationStore.ts b/src/store/useNotificationStore.ts
index da1566d..7fe66a7 100644
--- a/src/store/useNotificationStore.ts
+++ b/src/store/useNotificationStore.ts
@@ -1,41 +1,55 @@
+/**
+ * Notification Store with Auth-Aware Fetching
+ *
+ * Best Practice Pattern (2025):
+ * - Uses Zustand's subscribeWithSelector to react to auth state changes
+ * - Automatically fetches notifications when user becomes authenticated
+ * - Clears notifications when user logs out
+ * - No need for manual auth checks in individual methods
+ *
+ * References:
+ * - Obytes Expo Starter: https://starter.obytes.com/guides/authentication/
+ * - Zustand subscribeWithSelector: https://zustand.docs.pmnd.rs/middlewares/subscribe-with-selector
+ * - Expo Router Auth: https://docs.expo.dev/router/advanced/authentication/
+ */
 import { create } from 'zustand';
 import { persist, createJSONStorage } from 'zustand/middleware';
 import AsyncStorage from '@react-native-async-storage/async-storage';
 import {
   Notification,
-  NotificationBase,
   TripInvitationNotification,
   ChatMessageNotification,
   MarkNotificationsReadPayload,
   isChatMessageNotification,
   isTripInvitationNotification
 } from '../types/notification';
-import { ServerEvent } from '../types/events';
-import { apiClient } from '../api/api-client';
+import { api } from '../api/api-client';
 import { logger } from '../utils/logger';
+import { useAuthStore } from './useAuthStore';
+import type { AuthStatus } from '../types/auth';
 
 const NOTIFICATION_LIMIT = 100; // Max notifications to keep in state/storage
 const API_PAGE_LIMIT = 20; // How many notifications to fetch per API call
-const STORAGE_KEY = '@nomad_crew_notifications_v2'; // Use new key due to structure change
+const STORAGE_KEY = '@nomad_crew_notifications_v2';
 
 interface NotificationState {
   // Data
   notifications: Notification[];
   unreadCount: number;
-  hasHydrated: boolean; // To track store hydration from AsyncStorage
-  latestChatMessageToast: ChatMessageNotification | null; // For transient toast display
-  
+  hasHydrated: boolean;
+  latestChatMessageToast: ChatMessageNotification | null;
+
   // Loading and error states
   isFetching: boolean;
   isFetchingUnreadCount: boolean;
   isMarkingRead: boolean;
-  isHandlingAction: boolean; // e.g., accepting/declining invites
+  isHandlingAction: boolean;
   error: string | null;
-  
+
   // Pagination
   offset: number;
   hasMore: boolean;
-  
+
   // Actions
   fetchUnreadCount: () => Promise<void>;
   fetchNotifications: (options?: { loadMore?: boolean }) => Promise<void>;
@@ -47,6 +61,8 @@ interface NotificationState {
   clearChatToast: () => void;
   setHasHydrated: (state: boolean) => void;
   clearNotifications: () => void;
+  // Internal: called when auth status changes
+  _onAuthStatusChange: (status: AuthStatus, previousStatus: AuthStatus) => void;
 }
 
 export const useNotificationStore = create<NotificationState>()(
@@ -68,33 +84,70 @@ export const useNotificationStore = create<NotificationState>()(
         set({ hasHydrated: state });
       },
 
+      /**
+       * Internal handler for auth status changes
+       * Called by the subscription to useAuthStore
+       */
+      _onAuthStatusChange: (status: AuthStatus, previousStatus: AuthStatus) => {
+        logger.debug('NOTIFICATION', `Auth status changed: ${previousStatus} -> ${status}`);
+
+        if (status === 'authenticated' && previousStatus !== 'authenticated') {
+          // User just logged in - fetch notifications
+          logger.info('NOTIFICATION', 'User authenticated, fetching notifications...');
+          const state = get();
+          state.fetchUnreadCount();
+          state.fetchNotifications();
+        } else if (status === 'unauthenticated' && previousStatus === 'authenticated') {
+          // User just logged out - clear notifications
+          logger.info('NOTIFICATION', 'User logged out, clearing notifications');
+          get().clearNotifications();
+        }
+      },
+
       fetchUnreadCount: async () => {
+        // Guard: check auth status (not just token, for proper three-state handling)
+        const authStatus = useAuthStore.getState().status;
+        if (authStatus !== 'authenticated') {
+          logger.debug('NOTIFICATION', `fetchUnreadCount skipped: auth status is '${authStatus}'`);
+          return;
+        }
+
         if (get().isFetchingUnreadCount) return;
         set({ isFetchingUnreadCount: true, error: null });
+
         try {
-          const response = await apiClient.get<{ count: number }>('/api/notifications/count?status=unread');
+          const response = await api.get<{ count: number }>('/api/notifications/count?status=unread');
           set({ unreadCount: response.data.count });
-        } catch (err: any) {
-          const errorMessage = err.response?.data?.message || err.message || 'Failed to fetch unread count';
+        } catch (err: unknown) {
+          const error = err as { response?: { data?: { message?: string } }; message?: string };
+          const errorMessage = error.response?.data?.message || error.message || 'Failed to fetch unread count';
           set({ error: errorMessage });
-          logger.error('fetchUnreadCount failed:', err);
+          logger.error('NOTIFICATION', 'fetchUnreadCount failed:', err);
         } finally {
           set({ isFetchingUnreadCount: false });
         }
       },
 
       fetchNotifications: async (options = { loadMore: false }) => {
+        // Guard: check auth status
+        const authStatus = useAuthStore.getState().status;
+        if (authStatus !== 'authenticated') {
+          logger.debug('NOTIFICATION', `fetchNotifications skipped: auth status is '${authStatus}'`);
+          return;
+        }
+
         const { isFetching, offset, hasMore } = get();
         const limit = API_PAGE_LIMIT;
+
         if (isFetching || (!options.loadMore && offset > 0) || (options.loadMore && !hasMore)) {
-            return;
+          return;
         }
 
         set({ isFetching: true, error: null });
         const currentOffset = options.loadMore ? offset : 0;
 
         try {
-          const response = await apiClient.get<Notification[]>('/api/notifications', {
+          const response = await api.get<Notification[]>('/api/notifications', {
             params: { limit, offset: currentOffset },
           });
           const fetchedNotifications = response.data || [];
@@ -110,104 +163,94 @@ export const useNotificationStore = create<NotificationState>()(
           if (!options.loadMore) {
             get().fetchUnreadCount();
           }
-
-        } catch (err: any) {
-          const errorMessage = err.response?.data?.message || err.message || 'Failed to fetch notifications';
+        } catch (err: unknown) {
+          const error = err as { response?: { data?: { message?: string } }; message?: string };
+          const errorMessage = error.response?.data?.message || error.message || 'Failed to fetch notifications';
           set({ error: errorMessage });
-          logger.error('fetchNotifications failed:', err);
+          logger.error('NOTIFICATION', 'fetchNotifications failed:', err);
         } finally {
-           set({ isFetching: false });
+          set({ isFetching: false });
         }
       },
 
       markNotificationRead: async (notificationId: string) => {
         const notification = get().notifications.find(n => n.id === notificationId);
-        if (!notification || notification.isRead || get().isMarkingRead) return;
+        if (!notification || notification.read || get().isMarkingRead) return;
 
         set({ isMarkingRead: true, error: null });
         try {
-          await apiClient.patch(`/api/notifications/${notificationId}`);
+          await api.patch(`/api/notifications/${notificationId}`);
 
           set(state => ({
             notifications: state.notifications.map(n =>
-              n.id === notificationId ? { ...n, isRead: true } : n
+              n.id === notificationId ? { ...n, read: true } : n
             ),
           }));
 
           get().fetchUnreadCount();
-
-        } catch (err: any) {
-          const errorMessage = err.response?.data?.message || err.message || 'Failed to mark notification as read';
+        } catch (err: unknown) {
+          const error = err as { response?: { data?: { message?: string } }; message?: string };
+          const errorMessage = error.response?.data?.message || error.message || 'Failed to mark notification as read';
           set({ error: errorMessage });
-          logger.error('markNotificationRead failed:', err);
+          logger.error('NOTIFICATION', 'markNotificationRead failed:', err);
         } finally {
-            set({ isMarkingRead: false });
+          set({ isMarkingRead: false });
         }
       },
 
       markAllNotificationsRead: async () => {
         if (get().isMarkingRead || get().unreadCount === 0) return;
         set({ isMarkingRead: true, error: null });
+
         try {
           const payload: MarkNotificationsReadPayload = { status: 'read' };
-          await apiClient.patch('/api/notifications', payload);
+          await api.patch('/api/notifications', payload);
 
           set(state => ({
-            notifications: state.notifications.map(n => ({ ...n, isRead: true })),
+            notifications: state.notifications.map(n => ({ ...n, read: true })),
             unreadCount: 0,
           }));
-        } catch (err: any) {
-          const errorMessage = err.response?.data?.message || err.message || 'Failed to mark all notifications as read';
+        } catch (err: unknown) {
+          const error = err as { response?: { data?: { message?: string } }; message?: string };
+          const errorMessage = error.response?.data?.message || error.message || 'Failed to mark all notifications as read';
+          set({ error: errorMessage });
           get().fetchUnreadCount();
-          logger.error('markAllNotificationsRead failed:', err);
+          logger.error('NOTIFICATION', 'markAllNotificationsRead failed:', err);
         } finally {
-            set({ isMarkingRead: false });
+          set({ isMarkingRead: false });
         }
       },
 
       handleIncomingNotification: (notification: Notification) => {
-        // Ensure the notification object is valid (basic check)
         if (!notification || !notification.id || !notification.type) {
-          logger.warn('Received invalid notification object via WebSocket', notification);
+          logger.warn('NOTIFICATION', 'Received invalid notification object via WebSocket', notification);
           return;
         }
 
         // Handle CHAT_MESSAGE specifically
         if (isChatMessageNotification(notification)) {
           set(state => ({
-            // Set the transient state for the toast component to pick up
             latestChatMessageToast: notification,
-            // Increment count only if the backend marked it as unread
-            // Or potentially if the chat screen for this message isn't active (requires more context)
             unreadCount: notification.read ? state.unreadCount : state.unreadCount + 1,
           }));
-          // Note: The UI component displaying the toast will be responsible for calling clearChatToast
-          return; // Don't add chat messages to the persistent notification list
+          return;
         }
 
         // Handle all other notification types
         set(state => {
-          // Prevent duplicates if the same notification arrives multiple times via WS
           if (state.notifications.some(n => n.id === notification.id)) {
-            logger.debug('Duplicate notification received via WS, ignoring:', notification.id);
-            return state; // Return current state without modification
+            logger.debug('NOTIFICATION', 'Duplicate notification received via WS, ignoring:', notification.id);
+            return state;
           }
 
-          // Add the new notification to the beginning of the array
           const newNotifications = [notification, ...state.notifications];
-
-          // Pruning Logic: Enforce the notification limit
           if (newNotifications.length > NOTIFICATION_LIMIT) {
-            // Remove the oldest notification (the last element in the array)
             newNotifications.pop();
           }
 
           return {
             notifications: newNotifications,
-            // Increment count only if the backend marked it as unread
             unreadCount: notification.read ? state.unreadCount : state.unreadCount + 1,
-            // Decide if receiving a notification should reset pagination/scroll
-            // For now, let's not reset offset/hasMore automatically
           };
         });
       },
@@ -215,7 +258,7 @@ export const useNotificationStore = create<NotificationState>()(
       acceptTripInvitation: async (notification: TripInvitationNotification) => {
         if (get().isHandlingAction) return;
         if (!isTripInvitationNotification(notification)) {
-          logger.warn('acceptTripInvitation called with non-invite notification:', notification);
+          logger.warn('NOTIFICATION', 'acceptTripInvitation called with non-invite notification:', notification);
           return;
         }
 
@@ -223,28 +266,20 @@ export const useNotificationStore = create<NotificationState>()(
         const inviteId = notification.metadata.inviteId;
 
         try {
-          // POST to the backend's business logic endpoint for accepting
-          await apiClient.post(`/api/invitations/${inviteId}/accept`);
-
-          // Success! We rely on the backend to potentially send a follow-up
-          // WebSocket message (e.g., MEMBER_ADDED or TRIP_UPDATE) to reflect the change.
-          // Alternatively, we could optimistically remove/update the notification here.
-          // For now, just log success and potentially mark as read locally if desired.
-          logger.info(`Accepted trip invitation: ${inviteId}`);
+          await api.post(`/api/invitations/${inviteId}/accept`);
+          logger.info('NOTIFICATION', `Accepted trip invitation: ${inviteId}`);
 
-          // Optional: Mark as read locally after accepting
           set(state => ({
-             notifications: state.notifications.map(n =>
-               n.id === notification.id ? { ...n, read: true } : n
-             ),
-             // Adjust unreadCount if it was unread
-             unreadCount: !notification.read ? Math.max(0, state.unreadCount - 1) : state.unreadCount,
+            notifications: state.notifications.map(n =>
+              n.id === notification.id ? { ...n, read: true } : n
+            ),
+            unreadCount: !notification.read ? Math.max(0, state.unreadCount - 1) : state.unreadCount,
           }));
-
-        } catch (err: any) {
-          const errorMessage = err.response?.data?.message || err.message || 'Failed to accept trip invitation';
+        } catch (err: unknown) {
+          const error = err as { response?: { data?: { message?: string } }; message?: string };
+          const errorMessage = error.response?.data?.message || error.message || 'Failed to accept trip invitation';
           set({ error: errorMessage });
-          logger.error('acceptTripInvitation failed:', err);
+          logger.error('NOTIFICATION', 'acceptTripInvitation failed:', err);
         } finally {
           set({ isHandlingAction: false });
         }
@@ -253,31 +288,26 @@ export const useNotificationStore = create<NotificationState>()(
       declineTripInvitation: async (notification: TripInvitationNotification) => {
         if (get().isHandlingAction) return;
         if (!isTripInvitationNotification(notification)) {
-           logger.warn('declineTripInvitation called with non-invite notification:', notification);
-           return;
+          logger.warn('NOTIFICATION', 'declineTripInvitation called with non-invite notification:', notification);
+          return;
         }
 
         set({ isHandlingAction: true, error: null });
         const inviteId = notification.metadata.inviteId;
 
         try {
-          // POST to the backend's business logic endpoint for declining
-          await apiClient.post(`/api/invitations/${inviteId}/decline`);
-
-          // Success! Similar to accept, rely on backend for subsequent state updates via WS.
-          logger.info(`Declined trip invitation: ${inviteId}`);
+          await api.post(`/api/invitations/${inviteId}/decline`);
+          logger.info('NOTIFICATION', `Declined trip invitation: ${inviteId}`);
 
-          // Optional: Remove the notification locally after declining
           set(state => ({
             notifications: state.notifications.filter(n => n.id !== notification.id),
-            // Adjust unreadCount if it was unread
             unreadCount: !notification.read ? Math.max(0, state.unreadCount - 1) : state.unreadCount,
           }));
-
-        } catch (err: any) {
-          const errorMessage = err.response?.data?.message || err.message || 'Failed to decline trip invitation';
+        } catch (err: unknown) {
+          const error = err as { response?: { data?: { message?: string } }; message?: string };
+          const errorMessage = error.response?.data?.message || error.message || 'Failed to decline trip invitation';
           set({ error: errorMessage });
-          logger.error('declineTripInvitation failed:', err);
+          logger.error('NOTIFICATION', 'declineTripInvitation failed:', err);
         } finally {
           set({ isHandlingAction: false });
         }
@@ -289,8 +319,14 @@ export const useNotificationStore = create<NotificationState>()(
 
       clearNotifications: () => {
         AsyncStorage.removeItem(STORAGE_KEY)
-          .catch(err => logger.error('Failed to clear notifications', err));
-        set({ notifications: [], unreadCount: 0, offset: 0, hasMore: true, error: null });
+          .catch(err => logger.error('NOTIFICATION', 'Failed to clear notifications from storage', err));
+        set({
+          notifications: [],
+          unreadCount: 0,
+          offset: 0,
+          hasMore: true,
+          error: null
+        });
       }
     }),
     {
@@ -300,76 +336,71 @@ export const useNotificationStore = create<NotificationState>()(
         notifications: state.notifications,
       }),
       onRehydrateStorage: () => (state) => {
-         if (state) {
-            state.setHasHydrated(true);
-            logger.info('Notification store rehydrated from AsyncStorage.');
-         } else {
-            logger.warn('Notification store rehydration resulted in null state.');
-            useNotificationStore.setState({ hasHydrated: true });
-         }
+        if (state) {
+          state.setHasHydrated(true);
+          logger.info('NOTIFICATION', 'Store rehydrated from AsyncStorage');
+        } else {
+          logger.warn('NOTIFICATION', 'Store rehydration resulted in null state');
+          useNotificationStore.setState({ hasHydrated: true });
+        }
       },
     }
   )
 );
 
-// --- Post-Hydration Initial Data Fetching ---
-// We use a flag to ensure this runs only once after hydration completes.
-let hydrationCompleted = false;
-const unsubscribe = useNotificationStore.subscribe((state) => {
-  // Check if hydration is complete AND we haven't run this logic yet
-  if (state.hasHydrated && !hydrationCompleted) {
-    hydrationCompleted = true; // Mark as completed to prevent re-running
-    logger.info('Notification store hydration complete. Fetching initial data...');
-
-    // Use a microtask to delay execution slightly, ensuring the current state
-    // update cycle finishes and we get the truly latest state after hydration.
-    queueMicrotask(() => {
-       const currentState = useNotificationStore.getState(); // Get latest state inside microtask
-
-        // Fetch the accurate unread count from the server first
-        currentState.fetchUnreadCount().then(() => {
-          // After getting the count, fetch the first page of notifications
-          // only if the persisted list is empty. Adjust this condition if needed
-          // (e.g., fetch always, fetch if data is older than X).
-          if (currentState.notifications.length === 0) {
-             logger.info('No persisted notifications found, fetching first page.');
-             currentState.fetchNotifications(); // Fetch initial page (offset 0)
-          } else {
-             logger.info(`Loaded ${currentState.notifications.length} notifications from storage.`);
-             // If notifications were loaded, we might still want to refresh the count
-             // based on potentially missed WS messages while offline.
-             // fetchUnreadCount() already ran, so the count should be accurate.
-          }
-        }).catch(error => {
-            logger.error('Error during post-hydration fetchUnreadCount:', error);
-        });
-    });
-
-    // Optional: Unsubscribe after running once if we don't need to listen for further state changes here.
-    // However, keeping it subscribed is harmless.
-    // unsubscribe();
+// --- Auth Status Subscription (Best Practice Pattern) ---
+// Subscribe to auth status changes using subscribeWithSelector
+// This is the idiomatic way to react to auth state changes in Zustand
+// Reference: https://zustand.docs.pmnd.rs/middlewares/subscribe-with-selector
+const unsubscribeFromAuth = useAuthStore.subscribe(
+  // Selector: only react to status changes
+  (state) => state.status,
+  // Callback: called when status changes
+  (status, previousStatus) => {
+    const notificationStore = useNotificationStore.getState();
+    notificationStore._onAuthStatusChange(status, previousStatus);
+  },
+  {
+    // fireImmediately: false means don't call on initial subscription
+    // We only want to react to CHANGES in auth status
+    fireImmediately: false,
   }
-});
+);
 
-// --- WebSocket Integration Hook (Example - Keep for reference) ---
-/*
-import React, { useEffect } from 'react';
-import { useWebSocket } from './useWebSocket'; // Your WebSocket hook/manager
-import { useNotificationStore } from './useNotificationStore';
-import { Notification } from '../types/notification';
-
-const useNotificationWebSocket = () => {
-  const handleIncomingNotification = useNotificationStore(state => state.handleIncomingNotification);
-  const { lastJsonMessage } = useWebSocket(); // Assuming your hook provides the last message
-
-  useEffect(() => {
-    if (lastJsonMessage) {
-      // TODO: Add strong type checking/validation here (e.g., using Zod)
-      const notification = lastJsonMessage as Notification; // Replace with validation
-      if (notification && notification.id && notification.type) { // Basic check
-         handleIncomingNotification(notification);
+// --- Store Hydration Handler ---
+// When notification store finishes hydrating, check if we should fetch
+// (in case user was already authenticated before app restart)
+let hydrationHandled = false;
+const unsubscribeHydration = useNotificationStore.subscribe((state) => {
+  if (state.hasHydrated && !hydrationHandled) {
+    hydrationHandled = true;
+
+    // Check current auth status - if already authenticated, fetch notifications
+    // This handles the case where user was logged in before app restart
+    const authStatus = useAuthStore.getState().status;
+
+    if (authStatus === 'authenticated') {
+      logger.info('NOTIFICATION', 'Store hydrated with authenticated user, fetching notifications');
+      const notificationState = useNotificationStore.getState();
+      notificationState.fetchUnreadCount();
+
+      // Only fetch if no persisted notifications
+      if (notificationState.notifications.length === 0) {
+        notificationState.fetchNotifications();
       }
+    } else if (authStatus === 'idle') {
+      // Auth store hasn't initialized yet - the auth subscription will handle it
+      logger.debug('NOTIFICATION', 'Store hydrated, waiting for auth initialization');
+    } else {
+      logger.debug('NOTIFICATION', `Store hydrated, auth status: ${authStatus}`);
     }
-  }, [lastJsonMessage, handleIncomingNotification]);
+
+    // Unsubscribe after handling
+    unsubscribeHydration();
+  }
+});
+
+// Export for cleanup (useful for testing)
+export const cleanupNotificationSubscriptions = () => {
+  unsubscribeFromAuth();
 };
-*/ 
\ No newline at end of file
diff --git a/src/types/auth.ts b/src/types/auth.ts
index 37323c8..2172c1c 100644
--- a/src/types/auth.ts
+++ b/src/types/auth.ts
@@ -23,7 +23,12 @@ export interface User {
     password: string;
   }
   
-  export type AuthStatus = 'unauthenticated' | 'authenticated' | 'verifying';
+  // Three-state authentication pattern (recommended by Obytes Starter & community best practices)
+// - 'idle': Initial state - we don't know yet if user is authenticated (checking storage)
+// - 'authenticated': User has valid token
+// - 'unauthenticated': User has no token or token is invalid
+// - 'verifying': User is in email verification flow
+export type AuthStatus = 'idle' | 'unauthenticated' | 'authenticated' | 'verifying';
   
   export interface Session {
     access_token: string;
diff --git a/src/types/notification.ts b/src/types/notification.ts
index 28f6703..d018a21 100644
--- a/src/types/notification.ts
+++ b/src/types/notification.ts
@@ -49,32 +49,41 @@ const NotificationBaseSchema = z.object({
 // --- Zod Schema for Discriminated Union (for WebSocket Validation) ---
 // Define individual schemas for each notification type extending the base
 
-export const ZodNotificationSchema = z.discriminatedUnion('type', [
-  NotificationBaseSchema.extend({
-    type: z.literal('TRIP_INVITATION'),
-    metadata: TripInvitationMetadataSchema,
-  }),
-  NotificationBaseSchema.extend({
-    type: z.literal('CHAT_MESSAGE'),
-    metadata: ChatMessageMetadataSchema,
-  }),
-  NotificationBaseSchema.extend({
-    type: z.literal('MEMBER_ADDED'),
-    metadata: MemberAddedMetadataSchema,
-  }),
-  NotificationBaseSchema.extend({
-    type: z.literal('TRIP_UPDATE'), // Example
-    metadata: TripUpdateMetadataSchema,
-  }),
-  // Add other specific notification types here using the same pattern
-  // ...
-
-  // Fallback for generic/unknown types (if backend might send undefined types)
-  // Use cautiously, maybe log these instead of processing directly
-  NotificationBaseSchema.extend({
-    type: z.string(), // Allows any string not matched above
-    metadata: z.record(z.unknown()), // Allows any metadata shape
-  }),
+// Individual notification schemas with specific types
+const TripInvitationSchema = NotificationBaseSchema.extend({
+  type: z.literal('TRIP_INVITATION'),
+  metadata: TripInvitationMetadataSchema,
+});
+
+const ChatMessageSchema = NotificationBaseSchema.extend({
+  type: z.literal('CHAT_MESSAGE'),
+  metadata: ChatMessageMetadataSchema,
+});
+
+const MemberAddedSchema = NotificationBaseSchema.extend({
+  type: z.literal('MEMBER_ADDED'),
+  metadata: MemberAddedMetadataSchema,
+});
+
+const TripUpdateSchema = NotificationBaseSchema.extend({
+  type: z.literal('TRIP_UPDATE'),
+  metadata: TripUpdateMetadataSchema,
+});
+
+// Generic notification schema for unknown types
+const GenericNotificationSchema = NotificationBaseSchema.extend({
+  type: z.literal('GENERIC'),
+  metadata: z.record(z.unknown()),
+});
+
+// Use regular union instead of discriminatedUnion to allow flexible type matching
+// discriminatedUnion requires ALL schemas to have literal discriminator values
+export const ZodNotificationSchema = z.union([
+  TripInvitationSchema,
+  ChatMessageSchema,
+  MemberAddedSchema,
+  TripUpdateSchema,
+  GenericNotificationSchema,
 ]);
 
 // Infer the TypeScript type from the Zod schema
diff --git a/src/utils/notifications.ts b/src/utils/notifications.ts
index 928b7df..45f85bd 100644
--- a/src/utils/notifications.ts
+++ b/src/utils/notifications.ts
@@ -1,10 +1,25 @@
-import * as Notifications from 'expo-notifications';
+/**
+ * Notifications utility module with simulator-safe handling
+ *
+ * IMPORTANT: Push notifications don't work on iOS simulators due to APNs limitations.
+ * This module uses dynamic imports to prevent expo-notifications from loading on simulators,
+ * which would cause Keychain access errors.
+ *
+ * References:
+ * - https://docs.expo.dev/push-notifications/faq/
+ * - https://stackoverflow.com/questions/77033620/how-to-send-expo-push-notifications-for-ios-simulator-in-react-native-app
+ */
+
 import { Platform, Alert } from 'react-native';
 import { router } from 'expo-router';
 import { useAuthStore } from '@/src/store/useAuthStore';
 import { useTripStore } from '@/src/store/useTripStore';
 import { logger } from '@/src/utils/logger';
 import { jwtDecode } from 'jwt-decode';
+import Constants from 'expo-constants';
+
+// Lazy-loaded Notifications module - only imported on physical devices
+let Notifications: typeof import('expo-notifications') | null = null;
 
 // Define token interface
 interface InvitationToken {
@@ -25,17 +40,56 @@ export interface NotificationData {
   [key: string]: unknown;
 }
 
-// Configure notification behavior
-Notifications.setNotificationHandler({
-  handleNotification: async () => ({
-    shouldShowAlert: true,
-    shouldPlaySound: true,
-    shouldSetBadge: true,
-  }),
-});
+// Helper to check if we're on a physical device
+// Push notifications don't work on simulators/emulators
+const isPhysicalDevice = (): boolean => {
+  // Constants.isDevice is true for physical devices, false for simulators/emulators
+  // This check happens before any notification module import
+  return Constants.isDevice === true;
+};
+
+/**
+ * Initialize notifications module - call this early in app startup
+ * Only loads expo-notifications on physical devices to avoid Keychain errors on simulators
+ */
+export async function initializeNotifications(): Promise<boolean> {
+  if (!isPhysicalDevice()) {
+    logger.debug('NOTIFICATION', 'Skipping notification initialization: not a physical device (simulator/emulator)');
+    return false;
+  }
+
+  try {
+    // Dynamic import - only loads on physical devices
+    Notifications = await import('expo-notifications');
+
+    // Configure notification behavior
+    Notifications.setNotificationHandler({
+      handleNotification: async () => ({
+        shouldShowAlert: true,
+        shouldPlaySound: true,
+        shouldSetBadge: true,
+      }),
+    });
 
-// Configure how notifications are presented when the app is in the foreground
+    logger.debug('NOTIFICATION', 'Notification module initialized successfully');
+    return true;
+  } catch (error) {
+    logger.error('NOTIFICATION', 'Failed to initialize notifications:', error);
+    return false;
+  }
+}
+
+/**
+ * Configure notification listeners for the app
+ * Must be called after initializeNotifications()
+ */
 export function configureNotifications() {
+  // Skip if notifications module not loaded (simulator/emulator)
+  if (!Notifications) {
+    logger.debug('NOTIFICATION', 'Skipping notification configuration: module not loaded');
+    return;
+  }
+
   // Android-specific channel creation
   if (Platform.OS === 'android') {
     Notifications.setNotificationChannelAsync('default', {
@@ -51,28 +105,28 @@ export function configureNotifications() {
     const data = response.notification.request.content.data;
 
     if (data?.type === 'TRIP_INVITE' && data.token) {
-      const token = data.token;
+      const token = data.token as string;
       logger.debug('NOTIFICATION', `Processing invitation token: ${token.substring(0, 15)}...`);
-      
+
       const { user } = useAuthStore.getState();
-      
+
       // If user is logged in, process invitation directly
       if (user) {
         try {
           // Verify the token is valid and matches the logged-in user
           let isValid = true;
           let errorMessage = '';
-          
+
           try {
             const decodedToken: InvitationToken = jwtDecode(token);
             logger.debug('NOTIFICATION', 'Decoded token:', decodedToken);
-            
+
             // Check if token is expired
             if (decodedToken.exp && decodedToken.exp * 1000 < Date.now()) {
               isValid = false;
               errorMessage = 'Invitation has expired';
             }
-            
+
             // Check if the invitation is for this user
             if (decodedToken.inviteeEmail && user.email && decodedToken.inviteeEmail !== user.email) {
               isValid = false;
@@ -83,14 +137,14 @@ export function configureNotifications() {
             errorMessage = 'Invalid invitation format';
             logger.error('NOTIFICATION', 'Error decoding token:', error);
           }
-          
+
           if (isValid) {
             logger.debug('NOTIFICATION', 'Processing invitation for logged-in user');
             await useTripStore.getState().acceptInvitation(token);
-            
+
             // Navigate to trips page
             router.replace('/(tabs)/trips');
-            
+
             // Show success message
             Alert.alert(
               'Invitation Accepted',
@@ -126,11 +180,23 @@ export function configureNotifications() {
   Notifications.addNotificationReceivedListener((notification) => {
     // You can handle foreground notifications here if needed
     // For example, play a sound or show an in-app banner
+    logger.debug('NOTIFICATION', 'Foreground notification received:', notification.request.content.title);
   });
+
+  logger.debug('NOTIFICATION', 'Notification listeners configured');
 }
 
-// Helper function to show a local notification (useful for testing)
+/**
+ * Show a local notification (useful for testing)
+ * No-op on simulators/emulators
+ */
 export async function showLocalNotification(title: string, body: string, data?: NotificationData) {
+  // Skip if notifications module not loaded (simulator/emulator)
+  if (!Notifications) {
+    logger.debug('NOTIFICATION', `Local notification skipped (no module): ${title}`);
+    return;
+  }
+
   await Notifications.scheduleNotificationAsync({
     content: {
       title,
@@ -139,4 +205,11 @@ export async function showLocalNotification(title: string, body: string, data?:
     },
     trigger: null, // null means show immediately
   });
+}
+
+/**
+ * Check if notifications are available (physical device with module loaded)
+ */
+export function areNotificationsAvailable(): boolean {
+  return Notifications !== null;
 } 
\ No newline at end of file
